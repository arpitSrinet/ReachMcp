<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mobile Plans</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    :root {
      --primary-green: #00C853;
      --primary-green-hover: #063418;
      --button-radius: 8px;
      --button-padding: 14px 22px;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
      padding: 16px;
      background: #f5f5f5;
    }
    
    .plans-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 20px;
      max-width: 1400px;
      margin: 0 auto;
    }
    
    .plan-card {
      border: 2px solid #e0e0e0;
      border-radius: 12px;
      padding: 24px;
      background: white;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      transition: all 0.3s ease;
    }
    
    .plan-card:hover {
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
      transform: translateY(-2px);
    }
    
    .plan-header {
      margin-bottom: 16px;
      border-bottom: 1px solid #e0e0e0;
      padding-bottom: 12px;
    }
    
    .plan-name {
      font-size: 24px;
      font-weight: bold;
      color: #023d1a;
      margin-bottom: 8px;
    }
    
    .plan-data {
      font-size: 18px;
      color: #666;
    }
    
    .plan-pricing {
      margin-bottom: 16px;
    }
    
    .plan-meta {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px 16px;
      font-size: 13px;
      color: #455a64;
      margin-bottom: 12px;
      padding: 10px 12px;
      background: #f5fdf8;
      border-radius: 8px;
      border: 1px dashed #a5d6a7;
    }
    
    .plan-meta-label {
      font-weight: 600;
      color: #2e7d32;
    }
    
    .current-price {
      font-size: 32px;
      font-weight: bold;
      color: #00C853;
      display: block;
    }
    
    .original-price {
      font-size: 20px;
      color: #999;
      text-decoration: line-through;
      margin-right: 8px;
    }
    
    .taxes-note {
      font-size: 14px;
      color: #666;
      margin-top: 4px;
    }
    
    .discount-badge {
      display: inline-block;
      background: #4caf50;
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      margin-top: 8px;
    }
    
    .plan-features {
      margin-bottom: 16px;
    }
    
    .feature {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
      font-size: 14px;
    }
    
    .feature-icon {
      margin-right: 8px;
      font-size: 18px;
    }
    
    .select-button {
      width: 100%;
      background: var(--primary-green);
      color: white;
      border: none;
      padding: var(--button-padding);
      border-radius: var(--button-radius);
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.3s ease;
    }
    
    .select-button:hover {
      background: var(--primary-green-hover);
    }
    
    .broadband-facts {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid #e0e0e0;
    }
    
    .broadband-facts summary {
      cursor: pointer;
      font-weight: bold;
      color: #666;
      margin-bottom: 8px;
    }
    
    .facts-content {
      font-size: 12px;
      color: #666;
      background: #f5f5f5;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: monospace;
    }
  </style>
</head>
<body>
  <div class="plans-container" id="plans-container">
    <div style="padding: 40px; text-align: center; color: #666;">
      <div style="font-size: 18px; margin-bottom: 8px;">üì± Loading plans...</div>
      <div style="font-size: 14px; color: #999;">Please wait while we fetch the latest plans</div>
    </div>
  </div>

  <script>
    // Immediate diagnostic check
    console.log('üîç Plans widget initializing...', {
      hasOpenAI: typeof window.openai !== 'undefined',
      toolOutput: window.openai?.toolOutput,
      toolOutputType: typeof window.openai?.toolOutput,
      allKeys: window.openai ? Object.keys(window.openai) : []
    });

    // Function to render a single plan card
    function renderPlan(plan) {
      const planId = plan.id || plan.uniqueIdentifier;
      const name = plan.name || plan.displayName;
      const price = plan.price || plan.baseLinePrice || 0;
      const data = plan.data || plan.planData || 0;
      const dataUnit = plan.dataUnit || 'GB';
      const discountPctg = plan.discountPctg || 0;
      
      let originalPrice = null;
      let discountAmount = 0;
      if (discountPctg > 0) {
        originalPrice = Math.round(price / (1 - discountPctg / 100));
        discountAmount = Math.round(originalPrice - price);
      }
      
      const features = [];
      if (plan.isUnlimited || plan.unlimited) {
        features.push({ icon: 'üìû', text: 'Unlimited calls' });
      }
      if (data > 0) {
        features.push({ icon: 'üìä', text: `${data}${dataUnit} high-speed data` });
      }
      if (plan.overageAllowedData && plan.overageAllowedData > 0) {
        features.push({ icon: 'üìà', text: `${plan.overageAllowedData}${plan.overageAllowedDataUnit || 'MB'} additional data` });
      }
      if (plan.maxLines && plan.maxLines > 1) {
        features.push({ icon: 'üë•', text: `Up to ${plan.maxLines} lines` });
      }
      if (plan.additionalLinePrice) {
        features.push({ icon: '‚ûï', text: `Additional lines: $${plan.additionalLinePrice}/mo` });
      }
      if (plan.allowPlanChange) {
        features.push({ icon: 'üîÑ', text: 'Plan changes allowed' });
      }
      
      return `
        <div class="plan-card">
          <div class="plan-header">
            <div class="plan-name">${name}</div>
            <div class="plan-data">${data}${dataUnit}</div>
          </div>
          
          <div class="plan-pricing">
            ${originalPrice ? `<span class="original-price">$${originalPrice}</span>` : ''}
            <span class="current-price">$${price}/mo</span>
            <div class="taxes-note">(Taxes & fees included)</div>
            ${discountAmount > 0 ? `<div class="discount-badge">$${discountAmount} off applied</div>` : ''}
          </div>
          
          <div class="plan-meta">
            <div>
              <div class="plan-meta-label">Country</div>
              <div>${plan.countryCode || 'USA'}</div>
            </div>
            <div>
              <div class="plan-meta-label">Currency</div>
              <div>${plan.currency || 'USD'}</div>
            </div>
            <div>
              <div class="plan-meta-label">Max Lines</div>
              <div>${plan.maxLines || 1}</div>
            </div>
            <div>
              <div class="plan-meta-label">Status</div>
              <div>${plan.planStatus === 0 ? 'Active' : 'Inactive'}</div>
            </div>
            <div>
              <div class="plan-meta-label">Limited Offer</div>
              <div>${plan.isLimitedOffer ? 'Yes' : 'No'}</div>
            </div>
            <div>
              <div class="plan-meta-label">Overage</div>
              <div>
                ${plan.overageAllowedData && plan.overageAllowedData > 0
                  ? `${plan.overageAllowedData}${plan.overageAllowedDataUnit || 'MB'}`
                  : 'None'}
              </div>
            </div>
          </div>
          
          <div class="plan-features">
            ${features.map(f => `
              <div class="feature">
                <span class="feature-icon">${f.icon}</span>
                <span>${f.text}</span>
              </div>
            `).join('')}
          </div>
          
          <button class="select-button" onclick="selectPlan('${planId}', '${name.replace(/'/g, "\\'")}')">
            üîò Add to Cart
          </button>
          
          <details class="broadband-facts">
            <summary>üìã Broadband Facts & Technicals</summary>
            <div class="facts-content">
              <p>Plan ID: <code>${planId}</code></p>
              ${plan.planType ? `<p>Type: ${plan.planType}</p>` : ''}
              ${plan.serviceCode ? `<p>Service: ${plan.serviceCode}</p>` : ''}
              ${plan.planCharging ? `<p>Charging: ${plan.planCharging}</p>` : ''}
              ${plan.createdDate ? `<p>Created: ${plan.createdDate}</p>` : ''}
              <p>Talktime: ${plan.talktime}</p>
              <p>Text: ${plan.text}</p>
              <p>Throttle: ${plan.addThrottle ? 'Enabled' : 'Disabled'}${plan.throttleSpeed ? ` @ ${plan.throttleSpeed}${plan.throttleSpeedUnit || 'Kbps'}` : ''}</p>
              <p>Data Cut Off: ${plan.addDataCutOff ? 'Enabled' : 'Disabled'}</p>
              ${Array.isArray(plan.upGradableTo) && plan.upGradableTo.length
                ? `<p>Upgradable To: ${plan.upGradableTo.join(', ')}</p>` : ''}
              ${Array.isArray(plan.downGradableTo) && plan.downGradableTo.length
                ? `<p>Downgradable To: ${plan.downGradableTo.join(', ')}</p>` : ''}
            </div>
          </details>
        </div>
      `;
    }
    
    // Shared helper function to populate chat input with prompt
    function sendPrompt(message) {
      if (!message) {
        console.error('sendPrompt called without message');
        return;
      }
      
      console.log('sendPrompt called with:', message);
      
      // Try openPromptInput first (populates input field)
      if (window.openai?.openPromptInput) {
        try {
          window.openai.openPromptInput(message);
          console.log('‚úÖ Prompt added to chat input:', message);
          return;
        } catch (e) {
          console.error('Error with openPromptInput:', e);
        }
      } 
      
      // Fallback to sendFollowUpMessage (sends immediately)
      if (window.openai?.sendFollowUpMessage) {
        try {
          // Ensure message is a string
          const promptText = String(message);
          // Try calling with object format first
          if (typeof window.openai.sendFollowUpMessage === 'function') {
            // Check if it expects an object with 'prompt' property
            const result = window.openai.sendFollowUpMessage({ prompt: promptText });
            console.log('‚úÖ Prompt sent via sendFollowUpMessage (object):', promptText);
            return;
          }
        } catch (e) {
          // If object format fails, try string format
          try {
            window.openai.sendFollowUpMessage(promptText);
            console.log('‚úÖ Prompt sent via sendFollowUpMessage (string):', promptText);
            return;
          } catch (e2) {
            console.error('Error with sendFollowUpMessage (both formats):', e, e2);
          }
        }
      } 
      
      // Last resort: show alert
      console.error('No prompt API available. Available keys:', window.openai ? Object.keys(window.openai) : 'window.openai not found');
      alert(`Action: ${message}\n\nPlease type this in the chat and press Enter.`);
    }
    
    // Make sendPrompt available globally
    window.sendPrompt = sendPrompt;
    
    function selectPlan(planId, planName) {
      // Send prompt that will trigger add_to_cart tool
      sendPrompt(`Add ${planName} plan to my cart`);
    }
    
    // Function to check if toolOutput has valid data
    function hasValidToolOutput() {
      if (!window.openai) return false;
      
      // Check if toolOutput exists and is not null and has plans
      const toolOutput = window.openai.toolOutput;
      if (toolOutput && toolOutput !== null && typeof toolOutput === 'object') {
        // Check if it has plans array with data
        if (toolOutput.plans && Array.isArray(toolOutput.plans) && toolOutput.plans.length > 0) {
          return true;
        }
        // Or check structuredContent.plans
        if (toolOutput.structuredContent && toolOutput.structuredContent.plans && 
            Array.isArray(toolOutput.structuredContent.plans) && toolOutput.structuredContent.plans.length > 0) {
          return true;
        }
      }
      
      // Also check toolResponseMetadata
      const metadata = window.openai.toolResponseMetadata;
      if (metadata && metadata !== null && typeof metadata === 'object') {
        if (metadata.plans && Array.isArray(metadata.plans) && metadata.plans.length > 0) {
          return true;
        }
      }
      
      return false;
    }
    
    // Function to extract plans from toolOutput
    function extractPlans() {
      if (!window.openai) {
        console.log('‚ùå window.openai not available');
        return [];
      }
      
      // Try toolOutput first - ChatGPT injects structuredContent directly as toolOutput
      let toolOutput = window.openai.toolOutput;
      console.log('üîç Checking toolOutput:', {
        exists: !!toolOutput,
        isNull: toolOutput === null,
        type: typeof toolOutput,
        keys: toolOutput ? Object.keys(toolOutput) : []
      });
      
      if (toolOutput && toolOutput !== null && typeof toolOutput === 'object') {
        // Try direct plans property (most common case)
        if (toolOutput.plans && Array.isArray(toolOutput.plans)) {
          console.log('‚úÖ Found plans in toolOutput.plans:', toolOutput.plans.length);
          return toolOutput.plans;
        }
        // Try structuredContent.plans (nested case)
        if (toolOutput.structuredContent && toolOutput.structuredContent.plans && Array.isArray(toolOutput.structuredContent.plans)) {
          console.log('‚úÖ Found plans in toolOutput.structuredContent.plans:', toolOutput.structuredContent.plans.length);
          return toolOutput.structuredContent.plans;
        }
      }
      
      // Try toolResponseMetadata
      const metadata = window.openai.toolResponseMetadata;
      if (metadata && metadata !== null && typeof metadata === 'object') {
        console.log('üîç Checking toolResponseMetadata:', Object.keys(metadata));
        if (metadata.plans && Array.isArray(metadata.plans)) {
          console.log('‚úÖ Found plans in toolResponseMetadata.plans:', metadata.plans.length);
          return metadata.plans;
        }
      }
      
      console.log('‚ùå No plans found in any location');
      return [];
    }
    
    // Function to render all plans
    function renderAllPlans() {
      const container = document.getElementById('plans-container');
      if (!container) {
        console.error('Plans container not found');
        return false;
      }
      
      // Extract plans using the robust extraction function
      const plans = extractPlans();
    
      // Render all plans
      if (plans.length === 0) {
        // Don't show error yet - keep showing loading state and return false so retry continues
        // Only update if we're still showing the initial loading message
        if (container.innerHTML.includes('Loading plans')) {
          // Keep the loading message, don't change anything
        }
        return false;
      } else {
        const plansHtml = plans.map(renderPlan).join('');
        container.innerHTML = plansHtml;
        return true;
      }
    }
    
    
    // Permanent solution: Watch for toolOutput changing from null to data
    let rendered = false;
    let lastToolOutputValue = null;
    let checkCount = 0;
    const startTime = Date.now();
    const maxChecks = 1000; // Check for up to 25 seconds (1000 * 25ms)
    const minChecksBeforeError = 800; // Don't show error until at least 20 seconds (800 * 25ms = 20s)
    const minTimeBeforeError = 20000; // Don't show error until at least 20 seconds have passed (in milliseconds)
    
    // Very fast polling to detect when toolOutput changes from null to data
    function watchForToolOutputChange() {
      if (rendered) return; // Already rendered, stop watching
      
      checkCount++;
      const elapsedTime = Date.now() - startTime;
      
      // Check if toolOutput has valid data now
      if (hasValidToolOutput()) {
        const success = renderAllPlans();
        if (success) {
          console.log('‚úÖ Plans rendered successfully (toolOutput populated)');
          rendered = true;
          return;
        }
      }
      
      // Track value changes - if toolOutput changed from null to something, try rendering
      const currentValue = window.openai?.toolOutput;
      if (currentValue !== lastToolOutputValue) {
        lastToolOutputValue = currentValue;
        
        // If it changed from null to non-null, try rendering
        if (currentValue !== null && currentValue !== undefined) {
          console.log('toolOutput changed from null to:', typeof currentValue);
          const success = renderAllPlans();
          if (success) {
            console.log('‚úÖ Plans rendered (value change detected)');
            rendered = true;
            return;
          }
        }
      }
      
      // Continue watching if not rendered and haven't exceeded max checks
      if (!rendered && checkCount < maxChecks) {
        setTimeout(watchForToolOutputChange, 25); // Check every 25ms - even faster!
      } else if (!rendered && checkCount >= maxChecks) {
        // Only show error if we've waited at least the minimum time AND minimum checks
        // This prevents showing error too early (double safeguard)
        if (checkCount >= minChecksBeforeError && elapsedTime >= minTimeBeforeError) {
          const container = document.getElementById('plans-container');
          if (container) {
            // Only show error, not debug info (debug info should be in console only)
            container.innerHTML = '<p style="padding: 20px; text-align: center; color: #d32f2f;">‚ö†Ô∏è Unable to load plans. Please try again.</p>';
            console.error('Failed to render plans after', maxChecks, 'checks (', elapsedTime, 'ms)');
            // Log debug info to console only, not in UI
            if (window.openai) {
              console.error('Debug Info:', {
                toolOutputExists: !!window.openai.toolOutput,
                toolOutputIsNull: window.openai.toolOutput === null,
                toolResponseMetadataExists: !!window.openai.toolResponseMetadata,
                availableKeys: Object.keys(window.openai),
                toolOutputValue: window.openai.toolOutput
              });
            }
          }
        } else {
          // Still within minimum wait time, keep polling (extend maxChecks)
          setTimeout(watchForToolOutputChange, 25);
        }
      }
    }
    
    // Try to intercept toolOutput property changes using Proxy/defineProperty
    function setupToolOutputWatcher() {
      if (!window.openai) {
        // Wait for window.openai to be available
        setTimeout(setupToolOutputWatcher, 100);
        return;
      }
      
      try {
        // Store original value
        let currentValue = window.openai.toolOutput;
        
        // Try to redefine the property to watch for changes
        Object.defineProperty(window.openai, 'toolOutput', {
          get: function() {
            return currentValue;
          },
          set: function(newValue) {
            const oldValue = currentValue;
            currentValue = newValue;
            
            // If value changed from null/undefined to actual data, render immediately
            if ((oldValue === null || oldValue === undefined || oldValue === 'null') && 
                newValue !== null && newValue !== undefined && newValue !== 'null' && 
                typeof newValue === 'object') {
              
              console.log('‚úÖ toolOutput changed from null to data!', newValue);
              
              // Try to render immediately
              setTimeout(() => {
                if (!rendered) {
                  const success = renderAllPlans();
                  if (success) {
                    rendered = true;
                    console.log('‚úÖ Plans rendered (property setter detected)');
                  }
                }
              }, 10);
            }
          },
          configurable: true,
          enumerable: true
        });
        
        console.log('‚úÖ Set up toolOutput property watcher');
      } catch (e) {
        console.warn('Could not set up property watcher (this is OK, using polling instead):', e.message);
      }
    }
    
    // Try immediate render first (data might already be available)
    console.log('üöÄ Attempting immediate render...');
    if (hasValidToolOutput()) {
      const success = renderAllPlans();
      if (success) {
        rendered = true;
        console.log('‚úÖ Plans rendered immediately!');
      }
    }
    
    // Start the permanent solution immediately
    // 1. Set up property watcher (if possible)
    setupToolOutputWatcher();
    
    // 2. Start fast polling to detect changes (immediately, don't wait)
    watchForToolOutputChange();
    
    // 3. Also try rendering after a very short delay (in case data arrives just after page load)
    setTimeout(() => {
      if (!rendered && hasValidToolOutput()) {
        const success = renderAllPlans();
        if (success) {
          rendered = true;
          console.log('‚úÖ Plans rendered after short delay');
        }
      }
    }, 100);
    
    // 4. Try again after 500ms (common delay for data injection)
    setTimeout(() => {
      if (!rendered && hasValidToolOutput()) {
        const success = renderAllPlans();
        if (success) {
          rendered = true;
          console.log('‚úÖ Plans rendered after 500ms delay');
        }
      }
    }, 500);
    
    // 5. Try again after 1 second
    setTimeout(() => {
      if (!rendered && hasValidToolOutput()) {
        const success = renderAllPlans();
        if (success) {
          rendered = true;
          console.log('‚úÖ Plans rendered after 1s delay');
        }
      }
    }, 1000);
    
    // 3. Also listen for load event as fallback
    window.addEventListener("load", () => {
      console.log('üì• Load event fired, attempting to render plans');
      if (!rendered) {
        const success = renderAllPlans();
        if (success) {
          rendered = true;
          console.log('‚úÖ Plans rendered on load event');
        }
      }
    });
    
    // 4. Also try on DOMContentLoaded
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        console.log('üì• DOMContentLoaded fired, attempting to render plans');
        if (!rendered) {
          const success = renderAllPlans();
          if (success) {
            rendered = true;
            console.log('‚úÖ Plans rendered on DOMContentLoaded');
          }
        }
      });
    } else {
      // DOM already loaded, try immediately
      console.log('üì• DOM already loaded, attempting immediate render');
      if (!rendered) {
        const success = renderAllPlans();
        if (success) {
          rendered = true;
          console.log('‚úÖ Plans rendered (DOM already loaded)');
        }
      }
    }
  </script>
</body>
</html>
