<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mobile Plans</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --primary-green: #30ba95;
      --primary-green-hover: #269678;
      --card-radius: 24px;
      --button-radius: 999px;
      --button-padding: 14px 22px;
      --cta-bg: #000000;
      --cta-bg-hover: #121212;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
      padding: 12px;
      background: #ffffff;
      overflow-x: hidden;
    }

    .plans-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 16px;
      max-width: 1400px;
      margin: 0 auto;
      width: 100%;
    }

    .plan-card {
      border: 1px solid #e0e0e0;
      border-radius: var(--card-radius);
      padding: 20px;
      background: white;
      box-shadow: 0 12px 30px rgba(15, 23, 42, 0.12);
      transition: all 0.25s ease;
      display: flex;
      flex-direction: column;
    }

    .plan-card:hover {
      box-shadow: 0 18px 40px rgba(15, 23, 42, 0.18);
      transform: translateY(-4px);
      border-color: #d0d0d0;
    }

    .plan-header {
      margin-bottom: 20px;
    }

    .plan-name {
      font-size: 24px;
      font-weight: 600;
      color: #111827;
      margin-bottom: 8px;
    }

    .plan-data {
      font-size: 32px;
      font-weight: 700;
      color: #111827;
      line-height: 1.2;
    }

    .plan-pricing {
      margin-bottom: 16px;
    }

    .price-row {
      display: flex;
      align-items: baseline;
      gap: 8px;
      margin-bottom: 4px;
    }

    .original-price {
      font-size: 20px;
      color: #999;
      text-decoration: line-through;
    }

    .current-price {
      font-size: 24px;
      font-weight: 700;
      color: #111827;
    }

    .price-unit {
      font-size: 18px;
      font-weight: 500;
      color: #6b7280;
    }

    .taxes-note {
      font-size: 14px;
      color: #6b7280;
      margin-top: 4px;
    }

    .promotion-pills {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 20px;
    }

    .promotion-pill {
      display: inline-flex;
      align-items: center;
      background: var(--primary-green);
      color: white;
      padding: 6px 12px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.02em;
    }

    .plan-features {
      margin-bottom: 20px;
      flex-grow: 1;
    }

    .feature {
      display: flex;
      align-items: flex-start;
      margin-bottom: 12px;
      font-size: 14px;
      color: #111827;
      line-height: 1.5;
    }

    .feature-icon {
      margin-right: 10px;
      font-size: 18px;
      flex-shrink: 0;
      margin-top: 2px;
    }

    .select-button {
      width: 100%;
      background: var(--cta-bg);
      color: white;
      border: none;
      padding: var(--button-padding);
      border-radius: var(--button-radius);
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      margin-bottom: 12px;
    }

    .select-button:hover {
      background: var(--cta-bg-hover);
      transform: translateY(-1px);
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.25);
    }

    .select-button:active {
      transform: translateY(0);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    }

    .select-button--selected {
      background: var(--primary-green);
    }

    .select-button--selected:hover {
      background: var(--primary-green-hover);
      box-shadow: 0 10px 20px rgba(48, 186, 149, 0.35);
    }

    .broadband-facts-button {
      width: 100%;
      background: #f5f5f5;
      color: #666;
      border: 1px solid #e0e0e0;
      padding: 12px 16px;
      border-radius: var(--button-radius);
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    .broadband-facts-button:hover {
      background: #e5e5e5;
      border-color: #d0d0d0;
    }

    .broadband-facts-content {
      margin-top: 16px;
      padding: 16px;
      background: #f9fafb;
      border-radius: 12px;
      font-size: 12px;
      color: #666;
      display: none;
    }

    .broadband-facts-content.show {
      display: block;
    }

    .broadband-facts-content p {
      margin-bottom: 8px;
    }

    .broadband-facts-content code {
      background: #e5e7eb;
      padding: 2px 6px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 11px;
    }

    .line-selection-section {
      margin-top: 16px;
      padding: 16px;
      background: #f9fafb;
      border-radius: 12px;
      display: none;
      position: relative;
      z-index: 10;
    }

    .line-selection-section.show {
      display: block;
    }

    .line-selection-title {
      font-size: 14px;
      font-weight: 600;
      color: #111827;
      margin-bottom: 12px;
    }

    .line-checkboxes {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .line-checkbox-item {
      display: flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
      padding: 8px;
      border-radius: 8px;
      transition: background 0.2s ease;
    }

    .line-checkbox-item:hover {
      background: #f3f4f6;
    }

    .line-checkbox-item.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .line-checkbox-item.disabled:hover {
      background: transparent;
    }

    .line-checkbox {
      position: relative;
      width: 24px;
      height: 24px;
      flex-shrink: 0;
    }

    .line-checkbox input[type="checkbox"] {
      position: absolute;
      opacity: 0;
      cursor: pointer;
      width: 100%;
      height: 100%;
      margin: 0;
    }

    .line-checkbox-custom {
      width: 24px;
      height: 24px;
      border: 2px solid #d1d5db;
      border-radius: 50%;
      background: white;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    .line-checkbox input[type="checkbox"]:checked+.line-checkbox-custom {
      background: var(--primary-green);
      border-color: var(--primary-green);
    }

    .line-checkbox input[type="checkbox"]:checked+.line-checkbox-custom::after {
      content: '‚úì';
      color: white;
      font-size: 14px;
      font-weight: bold;
    }

    .line-checkbox input[type="checkbox"]:disabled+.line-checkbox-custom {
      background: #e5e7eb;
      border-color: #d1d5db;
      cursor: not-allowed;
    }

    .line-label {
      font-size: 14px;
      color: #111827;
      font-weight: 500;
    }


    .global-confirm-section {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: white;
      border-top: 1px solid #e0e0e0;
      padding: 20px 24px;
      box-shadow: 0 -4px 20px rgba(15, 23, 42, 0.1);
      z-index: 100;
      display: none;
      transition: transform 0.3s ease;
    }

    .global-confirm-section.show {
      display: block;
    }

    .global-confirm-content {
      max-width: 1400px;
      margin: 0 auto;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 20px;
    }

    .global-confirm-summary {
      flex: 1;
      font-size: 14px;
      color: #111827;
    }

    .global-confirm-summary-title {
      font-weight: 600;
      margin-bottom: 4px;
    }

    .global-confirm-summary-details {
      color: #6b7280;
      font-size: 13px;
    }

    .global-confirm-button {
      background: var(--primary-green);
      color: white;
      border: none;
      padding: 14px 32px;
      border-radius: var(--button-radius);
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      white-space: nowrap;
    }

    .global-confirm-button:hover:enabled {
      background: var(--primary-green-hover);
      transform: translateY(-1px);
      box-shadow: 0 10px 20px rgba(48, 186, 149, 0.35);
    }

    .global-confirm-button:disabled {
      background: #d1d5db;
      color: #9ca3af;
      cursor: not-allowed;
      opacity: 0.6;
    }

    body {
      padding-bottom: 120px;
    }

    .plans-container {
      margin-bottom: 120px;
    }
  </style>
</head>

<body>
  <div class="plans-container" id="plans-container">
    <div style="padding: 40px; text-align: center; color: #666;">
      <div style="font-size: 18px; margin-bottom: 8px;">üì± Loading plans...</div>
      <div style="font-size: 14px; color: #999;">Please wait while we fetch the latest plans</div>
    </div>
  </div>

  <!--
  <div class="global-confirm-section" id="global-confirm-section">
    <div class="global-confirm-content">
      <div class="global-confirm-summary">
        <div class="global-confirm-summary-title" id="global-confirm-title">Ready to confirm</div>
        <div class="global-confirm-summary-details" id="global-confirm-details">Select plans for all lines to continue
        </div>
      </div>
      <button class="global-confirm-button" id="global-confirm-button" onclick="confirmAllSelections()" disabled>
        Confirm All Selections
      </button>
    </div>
  </div>
  -->

  <script>
    // ============================================================================
    // CRITICAL: DUMMY_LINES must be defined FIRST before any other code runs
    // This prevents errors from cached/old code that might reference DUMMY_LINES
    // Using var ensures it's available globally (function-scoped), not just block-scoped
    // ============================================================================
    var DUMMY_LINES = [];
    window.DUMMY_LINES = DUMMY_LINES;

    // Additional safety: Ensure it's always available even if something tries to delete it
    Object.defineProperty(window, 'DUMMY_LINES', {
      value: DUMMY_LINES,
      writable: true,
      configurable: false, // Prevent deletion
      enumerable: true
    });

    // Immediate diagnostic check
    console.log('üîç Plans widget initializing...', {
      hasOpenAI: typeof window.openai !== 'undefined',
      toolOutput: window.openai?.toolOutput,
      toolOutputType: typeof window.openai?.toolOutput,
      allKeys: window.openai ? Object.keys(window.openai) : []
    });

    // Track selected plans
    const selectedPlans = new Set();

    // Track line-to-plan assignments: { lineId: planId }
    const linePlanAssignments = {};

    // Track plan names: { planId: planName }
    const planNames = {};

    // Track which plans have been selected (for showing checkboxes)
    const plansWithSelection = new Set();

    // Initialize currentLines - will be populated from toolOutput
    // Always ensure it's an array to prevent errors
    let currentLines = [];
    // Track lines that already have plans in cart
    let linesWithPlans = [];
    // Selection mode state from backend
    let selectionMode = 'initial';
    let activeLineId = null;
    let selectedPlansPerLine = {};
    let planModePrompted = false;

    // Function to extract lines from toolOutput
    // Also populates DUMMY_LINES with API data for compatibility with cached code
    function extractLines() {
      let extractedLines = [];

      if (!window.openai) {
        console.log('‚ùå window.openai not available for lines');
        // Sync DUMMY_LINES with empty array
        DUMMY_LINES = [];
        window.DUMMY_LINES = DUMMY_LINES;
        return [];
      }

      let toolOutput = window.openai.toolOutput;
      console.log('üîç Checking toolOutput for lines:', {
        exists: !!toolOutput,
        isNull: toolOutput === null,
        type: typeof toolOutput,
        keys: toolOutput ? Object.keys(toolOutput) : []
      });

      if (toolOutput && toolOutput !== null && typeof toolOutput === 'object') {
        // Check structuredContent first (this is where server.js puts the data)
        if (toolOutput.structuredContent) {
          if (toolOutput.structuredContent.lines && Array.isArray(toolOutput.structuredContent.lines) && toolOutput.structuredContent.lines.length > 0) {
            console.log('‚úÖ Found lines in toolOutput.structuredContent.lines:', toolOutput.structuredContent.lines.length);
            extractedLines = toolOutput.structuredContent.lines.map((line, index) => ({
              id: line.lineNumber || (index + 1),
              lineNumber: line.lineNumber || (index + 1),
              name: `Line ${line.lineNumber || (index + 1)}`,
              phoneNumber: line.phoneNumber || null,
              planSelected: line.planSelected || false,
              planId: line.planId || null
            }));
          } else if (toolOutput.structuredContent.lineCount && toolOutput.structuredContent.lineCount > 0) {
            console.log('‚úÖ Found lineCount in structuredContent, creating lines:', toolOutput.structuredContent.lineCount);
            extractedLines = [];
            for (let i = 1; i <= toolOutput.structuredContent.lineCount; i++) {
              extractedLines.push({
                id: i,
                lineNumber: i,
                name: `Line ${i}`,
                phoneNumber: null,
                planSelected: false,
                planId: null
              });
            }
          }
        }

        // Check for lines directly (if not found in structuredContent)
        if (extractedLines.length === 0 && toolOutput.lines && Array.isArray(toolOutput.lines) && toolOutput.lines.length > 0) {
          console.log('‚úÖ Found lines in toolOutput.lines:', toolOutput.lines.length);
          extractedLines = toolOutput.lines.map((line, index) => ({
            id: line.lineNumber || (index + 1),
            lineNumber: line.lineNumber || (index + 1),
            name: `Line ${line.lineNumber || (index + 1)}`,
            phoneNumber: line.phoneNumber || null,
            planSelected: line.planSelected || false,
            planId: line.planId || null
          }));
        }

        // Check for flowContext with lines (if not found yet)
        if (extractedLines.length === 0 && toolOutput.flowContext && toolOutput.flowContext.lines && Array.isArray(toolOutput.flowContext.lines)) {
          console.log('‚úÖ Found lines in toolOutput.flowContext.lines:', toolOutput.flowContext.lines.length);
          extractedLines = toolOutput.flowContext.lines.map((line, index) => ({
            id: line.lineNumber || (index + 1),
            lineNumber: line.lineNumber || (index + 1),
            name: `Line ${line.lineNumber || (index + 1)}`,
            phoneNumber: line.phoneNumber || null,
            planSelected: line.planSelected || false,
            planId: line.planId || null
          }));
        }

        // Check for lineCount and create lines from it (if not found yet)
        if (extractedLines.length === 0 && toolOutput.lineCount && toolOutput.lineCount > 0) {
          console.log('‚úÖ Found lineCount in toolOutput, creating lines:', toolOutput.lineCount);
          extractedLines = [];
          for (let i = 1; i <= toolOutput.lineCount; i++) {
            extractedLines.push({
              id: i,
              lineNumber: i,
              name: `Line ${i}`,
              phoneNumber: null,
              planSelected: false,
              planId: null
            });
          }
        }
      }

      // Check metadata if still no lines found
      if (extractedLines.length === 0) {
        const metadata = window.openai.toolResponseMetadata;
        if (metadata && metadata !== null && typeof metadata === 'object') {
          if (metadata.lines && Array.isArray(metadata.lines)) {
            console.log('‚úÖ Found lines in toolResponseMetadata.lines:', metadata.lines.length);
            extractedLines = metadata.lines.map((line, index) => ({
              id: line.lineNumber || (index + 1),
              lineNumber: line.lineNumber || (index + 1),
              name: `Line ${line.lineNumber || (index + 1)}`,
              phoneNumber: line.phoneNumber || null,
              planSelected: line.planSelected || false,
              planId: line.planId || null
            }));
          } else if (metadata.lineCount && metadata.lineCount > 0) {
            console.log('‚úÖ Found lineCount in metadata, creating lines:', metadata.lineCount);
            extractedLines = [];
            for (let i = 1; i <= metadata.lineCount; i++) {
              extractedLines.push({
                id: i,
                lineNumber: i,
                name: `Line ${i}`,
                phoneNumber: null,
                planSelected: false,
                planId: null
              });
            }
          }
        }
      }

      // CRITICAL: Populate DUMMY_LINES with API data for compatibility with cached code
      // This ensures old cached code that references DUMMY_LINES will get the actual API data
      DUMMY_LINES = Array.isArray(extractedLines) ? extractedLines : [];
      window.DUMMY_LINES = DUMMY_LINES;
      console.log('‚úÖ DUMMY_LINES synced with API data:', DUMMY_LINES.length, 'lines');

      if (extractedLines.length === 0) {
        console.log('‚ùå No lines found in any location');
      }

      if (toolOutput && toolOutput.structuredContent && toolOutput.structuredContent.linesWithPlans) {
        linesWithPlans = toolOutput.structuredContent.linesWithPlans;
        console.log('‚úÖ Found linesWithPlans:', linesWithPlans);
      } else {
        linesWithPlans = [];
      }

      // Extract selection mode state
      if (toolOutput && toolOutput.structuredContent) {
        selectionMode = toolOutput.structuredContent.selectionMode || 'initial';
        activeLineId = toolOutput.structuredContent.activeLineId || null;
        selectedPlansPerLine = toolOutput.structuredContent.selectedPlansPerLine || {};
        planModePrompted = !!toolOutput.structuredContent.planModePrompted;
        console.log('‚úÖ Selection state:', { selectionMode, activeLineId, selectedPlansPerLine, planModePrompted });
      }

      return extractedLines;
    }

    // Function to render a single plan card
    function renderPlan(plan) {
      const planId = plan.id || plan.uniqueIdentifier;
      const name = plan.name || plan.displayName;
      const price = plan.price || plan.baseLinePrice || 0;
      const data = plan.data || plan.planData || 0;
      const dataUnit = plan.dataUnit || 'GB';
      const discountPctg = plan.discountPctg || 0;
      const isSelected = selectedPlans.has(planId);

      let originalPrice = null;
      let discountAmount = 0;
      if (discountPctg > 0) {
        originalPrice = Math.round(price / (1 - discountPctg / 100));
        discountAmount = Math.round(originalPrice - price);
      }

      // Build promotion pills
      const promotions = [];
      if (discountAmount > 0) {
        promotions.push(`$${discountAmount.toFixed(2)} off applied`);
      }
      if (plan.overageAllowedData && plan.overageAllowedData > 0) {
        const overageGB = (plan.overageAllowedData / 1024).toFixed(0);
        promotions.push(`${overageGB}GB additional data`);
      }

      // Build features list (only essential ones)
      const features = [];
      if (plan.isUnlimited || plan.unlimited || plan.talktime === 'Unlimited') {
        features.push({ icon: 'üìû', text: 'Unlimited Talk & Text' });
      }
      if (data > 0) {
        const dataText = data >= 1
          ? `${data}${dataUnit} high-speed data${plan.addThrottle ? ' (reduced speeds thereafter)' : ''}`
          : `${data * 1024}MB high-speed data${plan.addThrottle ? ' (reduced speeds thereafter)' : ''}`;
        features.push({ icon: 'üíæ', text: dataText });
      }
      // Add mobile hotspot if available (checking if plan supports it)
      if (plan.mobileHotspot || plan.hotspotData) {
        const hotspotData = plan.hotspotData || data;
        features.push({ icon: 'üì∂', text: `${hotspotData}${dataUnit} mobile hotspot` });
      }
      // Add HD video streaming if available
      if (plan.hdVideo || plan.videoStreaming) {
        features.push({ icon: '‚ñ∂Ô∏è', text: 'HD video streaming' });
      }

      return `
        <div class="plan-card">
          <div class="plan-header">
            <div class="plan-name">${name}</div>
            <div class="plan-data">${data}${dataUnit}</div>
          </div>
          
          <div class="plan-pricing">
            <div class="price-row">
            ${originalPrice ? `<span class="original-price">$${originalPrice}</span>` : ''}
              <span class="current-price">$${price}</span>
              <span class="price-unit">/mo</span>
            </div>
            <div class="taxes-note">Includes taxes and fees</div>
          </div>
          
          ${promotions.length > 0 ? `
            <div class="promotion-pills">
              ${promotions.map(promo => `<span class="promotion-pill">${promo}</span>`).join('')}
            </div>
          ` : ''}
          
          <div class="plan-features">
            ${features.map(f => `
              <div class="feature">
                <span class="feature-icon">${f.icon}</span>
                <span>${f.text}</span>
              </div>
            `).join('')}
          </div>
          
          <button class="select-button" 
                  onclick="handlePlanSelection('${planId}', '${name.replace(/'/g, "\\'")}')">${selectionMode === 'applyAll'
          ? `Add ${name} to All Lines`
          : selectionMode === 'sequential' && activeLineId
            ? `Select ${name} for Line ${activeLineId}`
            : `Select Plan`
        }</button>
          
          <div class="line-selection-section" style="display: none;">
            <div class="line-selection-title">Lines:</div>
            <div class="line-checkboxes">
              ${(Array.isArray(currentLines) ? currentLines : []).map(line => {
          const lineIdStr = String(line.id);
          const hasPlanInCart = linesWithPlans.includes(line.id);
          const hasSelectedPlan = selectedPlansPerLine[lineIdStr] !== undefined;
          const isThisPlan = selectedPlansPerLine[lineIdStr] === planId;
          const isChecked = hasPlanInCart || isThisPlan;

          return `
                  <label class="line-checkbox-item disabled" onclick="return false;">
                    <div class="line-checkbox">
                      <input type="checkbox" 
                             id="line-${line.id}-plan-${planId}"
                             ${isChecked ? 'checked' : ''}
                             disabled>
                      <span class="line-checkbox-custom"></span>
                    </div>
                    <span class="line-label">
                      ${line.name} ${line.phoneNumber ? `(${line.phoneNumber})` : ''}
                      ${hasPlanInCart ? '<span style="font-size: 12px; color: #30ba95; margin-left: 6px;">(In cart)</span>' : ''}
                      ${isThisPlan ? '<span style="font-size: 12px; color: #2563eb; margin-left: 6px;">(Selected)</span>' : ''}
                    </span>
                  </label>
                `;
        }).join('')}
            </div>
          </div>
          
          <button class="broadband-facts-button" onclick="toggleBroadbandFacts('${planId}')">
            <span>Broadband Facts</span>
            <span id="facts-icon-${planId}">‚úì</span>
          </button>
          
          <div class="broadband-facts-content" id="facts-${planId}">
              ${plan.planType ? `<p>Type: ${plan.planType}</p>` : ''}
              ${plan.serviceCode ? `<p>Service: ${plan.serviceCode}</p>` : ''}
              ${plan.planCharging ? `<p>Charging: ${plan.planCharging}</p>` : ''}
            <p>Talktime: ${plan.talktime === -1 || plan.talktime === '-1' ? 'No' : (plan.talktime || 'N/A')}</p>
            <p>Text: ${plan.text === -1 || plan.text === '-1' ? 'No' : (plan.text || 'N/A')}</p>
              <p>Throttle: ${plan.addThrottle ? 'Enabled' : 'Disabled'}${plan.throttleSpeed ? ` @ ${plan.throttleSpeed}${plan.throttleSpeedUnit || 'Kbps'}` : ''}</p>
              <p>Data Cut Off: ${plan.addDataCutOff ? 'Enabled' : 'Disabled'}</p>
              ${Array.isArray(plan.upGradableTo) && plan.upGradableTo.length
          ? `<p>Upgradable To: ${plan.upGradableTo.join(', ')}</p>` : ''}
              ${Array.isArray(plan.downGradableTo) && plan.downGradableTo.length
          ? `<p>Downgradable To: ${plan.downGradableTo.join(', ')}</p>` : ''}
            </div>
        </div>
      `;
    }

    // New simplified plan selection handler
    function handlePlanSelection(planId, planName) {
      console.log('handlePlanSelection called:', { planId, planName, selectionMode, activeLineId });

      let message = '';

      if (selectionMode === 'applyAll') {
        message = `Add ${planName} plan (ID: ${planId}) to all lines`;
      } else if (selectionMode === 'sequential' && activeLineId) {
        message = `Add ${planName} plan (ID: ${planId}) to line ${activeLineId}`;
      } else {
        // Initial or single line logic check
        const toolOutput = window.openai && window.openai.toolOutput ? window.openai.toolOutput : {};
        const sc = toolOutput.structuredContent || {};
        const lineCount = sc.lineCount || (Array.isArray(currentLines) ? currentLines.length : 0) || 1;
        const defaultLine = activeLineId || 1;

        if (lineCount > 1 && !planModePrompted) {
          // Multi-line initial selection - ask mode
          message = `I am interested in ${planName} plan (ID: ${planId}). Should I apply this to all lines or mix and match?`;
        } else {
          // Single line or follow-up after initial prompt
          message = `Add ${planName} plan (ID: ${planId}) to line ${defaultLine}`;
        }
      }

      sendPrompt(message);
    }

    // Shared helper function to populate chat input with prompt
    function sendPrompt(message) {
      if (!message) {
        console.error('sendPrompt called without message');
        return;
      }

      console.log('sendPrompt called with:', message);

      // Try openPromptInput first (populates input field)
      if (window.openai?.openPromptInput) {
        try {
          window.openai.openPromptInput(message);
          console.log('‚úÖ Prompt added to chat input:', message);
          return;
        } catch (e) {
          console.error('Error with openPromptInput:', e);
        }
      }

      // Fallback to sendFollowUpMessage (sends immediately)
      if (window.openai?.sendFollowUpMessage) {
        try {
          const promptText = String(message);
          if (typeof window.openai.sendFollowUpMessage === 'function') {
            const result = window.openai.sendFollowUpMessage({ prompt: promptText });
            console.log('‚úÖ Prompt sent via sendFollowUpMessage (object):', promptText);
            return;
          }
        } catch (e) {
          try {
            window.openai.sendFollowUpMessage(promptText);
            console.log('‚úÖ Prompt sent via sendFollowUpMessage (string):', promptText);
            return;
          } catch (e2) {
            console.error('Error with sendFollowUpMessage (both formats):', e, e2);
          }
        }
      }

      console.error('No prompt API available. Available keys:', window.openai ? Object.keys(window.openai) : 'window.openai not found');
      alert(`Action: ${message}\n\nPlease type this in the chat and press Enter.`);
    }

    // Make functions available globally
    window.sendPrompt = sendPrompt;
    window.selectPlan = selectPlan;
    window.toggleLineAssignment = toggleLineAssignment;
    // window.confirmAllSelections = confirmAllSelections;
    window.toggleBroadbandFacts = toggleBroadbandFacts;

    function selectPlan(planId, planName, buttonEl) {
      const isSelected = selectedPlans.has(planId);

      if (isSelected) {
        // Deselect
        selectedPlans.delete(planId);
        plansWithSelection.delete(planId);

        // Remove plan name
        delete planNames[planId];

        // Remove all line assignments for this plan
        Object.keys(linePlanAssignments).forEach(lineId => {
          if (linePlanAssignments[lineId] === planId) {
            delete linePlanAssignments[lineId];
            // Also uncheck the checkbox if it exists
            const checkbox = document.getElementById(`line-${lineId}-plan-${planId}`);
            if (checkbox) {
              checkbox.checked = false;
            }
          }
        });

        if (buttonEl) {
          buttonEl.classList.remove('select-button--selected');
          buttonEl.textContent = 'Select Plan';
        }

        // Hide line selection section
        const lineSection = document.getElementById(`line-selection-${planId}`);
        if (lineSection) {
          lineSection.classList.remove('show');
        }

        // Re-render all plans to update disabled states
        renderAllPlans();
      } else {
        // Select
        selectedPlans.add(planId);
        plansWithSelection.add(planId);

        // Store plan name for later use
        planNames[planId] = planName;

        if (buttonEl) {
          buttonEl.classList.add('select-button--selected');
          buttonEl.textContent = '‚úì Selected';
        }

        // Show line selection section
        const lineSection = document.getElementById(`line-selection-${planId}`);
        if (lineSection) {
          lineSection.classList.add('show');
        }

        // Re-render all plans to update disabled states
        renderAllPlans();
      }

      // updateConfirmButtons();
    }

    function toggleLineAssignment(lineId, planId, planName) {
      // Ensure lineId is a string for consistent key usage
      const lineIdStr = String(lineId);
      const checkbox = document.getElementById(`line-${lineId}-plan-${planId}`);
      if (!checkbox) return;

      const isChecked = checkbox.checked;

      console.log('üîÑ toggleLineAssignment:', { lineId, lineIdStr, planId, isChecked, currentAssignments: Object.assign({}, linePlanAssignments) });

      if (isChecked) {
        // If this line already has a plan assigned, remove it first
        if (linePlanAssignments[lineIdStr] && linePlanAssignments[lineIdStr] !== planId) {
          const oldPlanId = linePlanAssignments[lineIdStr];
          // Uncheck the old plan's checkbox for this line
          const oldCheckbox = document.getElementById(`line-${lineId}-plan-${oldPlanId}`);
          if (oldCheckbox) {
            oldCheckbox.checked = false;
          }
        }

        // Assign this plan to this line
        linePlanAssignments[lineIdStr] = planId;
      } else {
        // Remove assignment
        if (linePlanAssignments[lineIdStr] === planId) {
          delete linePlanAssignments[lineIdStr];
        }
      }

      console.log('‚úÖ toggleLineAssignment complete:', { linePlanAssignments: Object.assign({}, linePlanAssignments) });

      // Re-render all plans to update disabled states
      renderAllPlans();
      // updateConfirmButtons();
    }

    /*
    function updateConfirmButtons() {
      // DEFENSIVE: Ensure DUMMY_LINES exists (for cached code compatibility)
      // This handles cases where cached/old code might reference DUMMY_LINES
      if (typeof DUMMY_LINES === 'undefined') {
        // Try to get from window first
        if (typeof window.DUMMY_LINES !== 'undefined') {
          DUMMY_LINES = window.DUMMY_LINES;
        } else {
          // Create it if it doesn't exist
          window.DUMMY_LINES = [];
          DUMMY_LINES = window.DUMMY_LINES;
        }
      }

      // Update current lines from toolOutput - ALWAYS update, even if empty
      const extractedLines = extractLines();
      // Always assign to ensure currentLines is in sync with toolOutput
      currentLines = Array.isArray(extractedLines) ? extractedLines : [];
      console.log('‚úÖ updateConfirmButtons: Lines updated:', currentLines.length, currentLines);

      // Ensure currentLines is always an array (never undefined or null)
      if (!Array.isArray(currentLines)) {
        currentLines = [];
      }

      // Check if all lines have plans assigned (convert line.id to string for consistent comparison)
      const allLinesAssigned = currentLines.length > 0 && currentLines.every(line => {
        const lineIdStr = String(line.id);
        const hasAssignment = !!linePlanAssignments[lineIdStr];
        const hasPlanInCart = linesWithPlans.includes(line.id);

        if (!hasAssignment && !hasPlanInCart) {
          console.log('‚ùå Line missing assignment:', { lineId: line.id, lineIdStr, lineName: line.name });
        }
        return hasAssignment || hasPlanInCart;
      });

      // Get all plan-to-line assignments
      const assignments = [];
      currentLines.forEach(line => {
        const lineIdStr = String(line.id);
        if (linePlanAssignments[lineIdStr]) {
          assignments.push({
            lineId: line.id,
            lineName: line.name,
            planId: linePlanAssignments[lineIdStr]
          });
        }
      });

      console.log('‚úÖ updateConfirmButtons: State check', {
        totalLines: currentLines.length,
        assignedLines: assignments.length,
        allLinesAssigned: allLinesAssigned,
        linePlanAssignments: Object.assign({}, linePlanAssignments),
        currentLinesIds: currentLines.map(l => String(l.id))
      });

      // Update global confirm section
      const globalConfirmSection = document.getElementById('global-confirm-section');
      const globalConfirmButton = document.getElementById('global-confirm-button');
      const globalConfirmTitle = document.getElementById('global-confirm-title');
      const globalConfirmDetails = document.getElementById('global-confirm-details');

      if (globalConfirmSection && globalConfirmButton && globalConfirmTitle && globalConfirmDetails) {
        // Show section if there are any assignments
        if (assignments.length > 0) {
          globalConfirmSection.classList.add('show');

          // Update summary
          const assignedLinesCount = assignments.length;
          const totalLinesCount = currentLines.length;

          if (allLinesAssigned && totalLinesCount > 0) {
            globalConfirmTitle.textContent = `All ${totalLinesCount} lines have plans selected`;
            globalConfirmDetails.textContent = `Ready to add all plans to cart`;
            globalConfirmButton.disabled = false;
          } else {
            globalConfirmTitle.textContent = `${assignedLinesCount} of ${totalLinesCount} lines have plans`;
            globalConfirmDetails.textContent = `Select plans for all lines to continue`;
            globalConfirmButton.disabled = true;
          }
        } else {
          globalConfirmSection.classList.remove('show');
          globalConfirmButton.disabled = true;
        }

        // Adjust container padding based on confirm section visibility
        const container = document.getElementById('plans-container');
        if (container) {
          if (globalConfirmSection.classList.contains('show')) {
            container.style.paddingBottom = '140px';
          } else {
            container.style.paddingBottom = '0';
          }
        }
      }
    }
    */

    /*
    function confirmAllSelections() {
      // Update current lines from toolOutput
      const extractedLines = extractLines();
      currentLines = Array.isArray(extractedLines) ? extractedLines : [];

      // Get all plan-to-line assignments from all cards
      const allAssignments = [];

      currentLines.forEach(line => {
        const lineIdStr = String(line.id);
        if (linePlanAssignments[lineIdStr]) {
          const planId = linePlanAssignments[lineIdStr];
          const planName = planNames[planId] || `Plan ${planId}`;

          allAssignments.push({
            lineId: line.id,
            lineNumber: line.lineNumber || line.id,
            lineName: line.name,
            planId: planId,
            planName: planName
          });
        }
      });

      if (allAssignments.length === 0) {
        // If we have plans in cart (and all lines are satisfied), allow user to proceed
        const hasPlansInCart = linesWithPlans.length > 0;

        // Check if all lines really have plans (assigned or in cart)
        const allSatisfied = currentLines.every(line => {
          const lineIdStr = String(line.id);
          return !!linePlanAssignments[lineIdStr] || linesWithPlans.includes(line.id);
        });

        if (allSatisfied && hasPlansInCart) {
          sendPrompt("I have confirmed my plan selections.");
          return;
        }

        alert('Please select at least one plan for a line.');
        return;
      }

      // Check if all lines have plans (convert line.id to string for consistent comparison)
      const allLinesAssigned = currentLines.length > 0 && currentLines.every(line => {
        const lineIdStr = String(line.id);
        return !!linePlanAssignments[lineIdStr] || linesWithPlans.includes(line.id);
      });
      if (!allLinesAssigned) {
        alert('Please select plans for all lines before confirming.');
        return;
      }

      // Build individual add_to_cart commands for each plan-line combination
      // Format: "Add [plan name] plan (ID: [planId]) to line [lineNumber]"
      const commands = allAssignments.map(a => {
        return `Add ${a.planName} plan (ID: ${a.planId}) to line ${a.lineNumber}`;
      });

      // Send all commands as a single message - AI will parse and execute multiple add_to_cart calls
      const message = `Please add the following plans to my cart:\n\n${commands.join('\n')}\n\nUse the add_to_cart tool with itemType="plan", itemId for each plan, and the corresponding lineNumber for each line.`;
      sendPrompt(message);

      console.log('‚úÖ Confirmed selections, sending to cart:', {
        assignments: allAssignments,
        commands: commands
      });

      // Optionally clear selections after confirmation
      // Uncomment if you want to reset after adding to cart
      // currentLines.forEach(line => {
      //   delete linePlanAssignments[line.id];
      // });
      // plansWithSelection.clear();
      // selectedPlans.clear();
      // planNames = {};
      // renderAllPlans();
    }
    */

    function toggleBroadbandFacts(planId) {
      const content = document.getElementById(`facts-${planId}`);
      const icon = document.getElementById(`facts-icon-${planId}`);

      if (content && icon) {
        const isShowing = content.classList.contains('show');
        if (isShowing) {
          content.classList.remove('show');
          icon.textContent = '‚úì';
        } else {
          content.classList.add('show');
          icon.textContent = '‚ñº';
        }
      }
    }

    // Function to check if toolOutput has valid data
    function hasValidToolOutput() {
      if (!window.openai) return false;

      const toolOutput = window.openai.toolOutput;
      if (toolOutput && toolOutput !== null && typeof toolOutput === 'object') {
        if (toolOutput.plans && Array.isArray(toolOutput.plans) && toolOutput.plans.length > 0) {
          return true;
        }
        if (toolOutput.structuredContent && toolOutput.structuredContent.plans &&
          Array.isArray(toolOutput.structuredContent.plans) && toolOutput.structuredContent.plans.length > 0) {
          return true;
        }
      }

      const metadata = window.openai.toolResponseMetadata;
      if (metadata && metadata !== null && typeof metadata === 'object') {
        if (metadata.plans && Array.isArray(metadata.plans) && metadata.plans.length > 0) {
          return true;
        }
      }

      return false;
    }

    // Function to extract plans from toolOutput
    function extractPlans() {
      if (!window.openai) {
        console.log('‚ùå window.openai not available');
        return [];
      }

      let toolOutput = window.openai.toolOutput;
      console.log('üîç Checking toolOutput:', {
        exists: !!toolOutput,
        isNull: toolOutput === null,
        type: typeof toolOutput,
        keys: toolOutput ? Object.keys(toolOutput) : []
      });

      if (toolOutput && toolOutput !== null && typeof toolOutput === 'object') {
        if (toolOutput.plans && Array.isArray(toolOutput.plans)) {
          console.log('‚úÖ Found plans in toolOutput.plans:', toolOutput.plans.length);
          return toolOutput.plans;
        }
        if (toolOutput.structuredContent && toolOutput.structuredContent.plans && Array.isArray(toolOutput.structuredContent.plans)) {
          console.log('‚úÖ Found plans in toolOutput.structuredContent.plans:', toolOutput.structuredContent.plans.length);
          return toolOutput.structuredContent.plans;
        }
      }

      const metadata = window.openai.toolResponseMetadata;
      if (metadata && metadata !== null && typeof metadata === 'object') {
        console.log('üîç Checking toolResponseMetadata:', Object.keys(metadata));
        if (metadata.plans && Array.isArray(metadata.plans)) {
          console.log('‚úÖ Found plans in toolResponseMetadata.plans:', metadata.plans.length);
          return metadata.plans;
        }
      }

      console.log('‚ùå No plans found in any location');
      return [];
    }

    // Function to render all plans
    function renderAllPlans() {
      const container = document.getElementById('plans-container');
      if (!container) {
        console.error('Plans container not found');
        return false;
      }

      const plans = extractPlans();

      // Update current lines from toolOutput - ALWAYS update, even if empty
      const extractedLines = extractLines();
      // Always assign to ensure currentLines is in sync with toolOutput
      currentLines = Array.isArray(extractedLines) ? extractedLines : [];
      console.log('‚úÖ Lines updated:', currentLines.length, 'lines');

      // Ensure currentLines is always an array (never undefined or null)
      if (!Array.isArray(currentLines)) {
        currentLines = [];
      }

      if (plans.length === 0) {
        if (container.innerHTML.includes('Loading plans')) {
          // Keep the loading message
        }
        return false;
      } else {
        const plansHtml = plans.map(renderPlan).join('');
        container.innerHTML = plansHtml;

        // Update confirm buttons after rendering
        setTimeout(() => {
          // updateConfirmButtons();
        }, 10);

        return true;
      }
    }

    // Permanent solution: Watch for toolOutput changing from null to data
    let rendered = false;
    let lastToolOutputValue = null;
    let lastLinesCount = 0;
    let checkCount = 0;
    const startTime = Date.now();
    const maxChecks = 1000;
    const minChecksBeforeError = 800;
    const minTimeBeforeError = 20000;

    function watchForToolOutputChange() {
      checkCount++;
      const elapsedTime = Date.now() - startTime;

      // Check if lines data has changed
      const extractedLines = extractLines();
      const linesChanged = extractedLines.length !== lastLinesCount;
      if (linesChanged) {
        lastLinesCount = extractedLines.length;
        // Always update currentLines when lines change, even if empty
        currentLines = Array.isArray(extractedLines) ? extractedLines : [];
        console.log('‚úÖ Lines data updated, re-rendering plans:', currentLines.length, 'lines');
        // Re-render even if already rendered to update line checkboxes
        const success = renderAllPlans();
        if (success && !rendered) {
          rendered = true;
        }
      }

      if (!rendered) {
        if (hasValidToolOutput()) {
          const success = renderAllPlans();
          if (success) {
            console.log('‚úÖ Plans rendered successfully (toolOutput populated)');
            rendered = true;
            return;
          }
        }

        const currentValue = window.openai?.toolOutput;
        if (currentValue !== lastToolOutputValue) {
          lastToolOutputValue = currentValue;

          if (currentValue !== null && currentValue !== undefined) {
            console.log('toolOutput changed from null to:', typeof currentValue);
            const success = renderAllPlans();
            if (success) {
              console.log('‚úÖ Plans rendered (value change detected)');
              rendered = true;
              return;
            }
          }
        }
      }

      if (checkCount < maxChecks) {
        setTimeout(watchForToolOutputChange, 25);
      } else if (!rendered && checkCount >= maxChecks) {
        if (checkCount >= minChecksBeforeError && elapsedTime >= minTimeBeforeError) {
          const container = document.getElementById('plans-container');
          if (container) {
            container.innerHTML = '<p style="padding: 20px; text-align: center; color: #d32f2f;">‚ö†Ô∏è Unable to load plans. Please try again.</p>';
            console.error('Failed to render plans after', maxChecks, 'checks (', elapsedTime, 'ms)');
            if (window.openai) {
              console.error('Debug Info:', {
                toolOutputExists: !!window.openai.toolOutput,
                toolOutputIsNull: window.openai.toolOutput === null,
                toolResponseMetadataExists: !!window.openai.toolResponseMetadata,
                availableKeys: Object.keys(window.openai),
                toolOutputValue: window.openai.toolOutput
              });
            }
          }
        } else {
          setTimeout(watchForToolOutputChange, 25);
        }
      }
    }

    function setupToolOutputWatcher() {
      if (!window.openai) {
        setTimeout(setupToolOutputWatcher, 100);
        return;
      }

      try {
        let currentValue = window.openai.toolOutput;

        Object.defineProperty(window.openai, 'toolOutput', {
          get: function () {
            return currentValue;
          },
          set: function (newValue) {
            const oldValue = currentValue;
            currentValue = newValue;

            if ((oldValue === null || oldValue === undefined || oldValue === 'null') &&
              newValue !== null && newValue !== undefined && newValue !== 'null' &&
              typeof newValue === 'object') {

              console.log('‚úÖ toolOutput changed from null to data!', newValue);

              setTimeout(() => {
                if (!rendered) {
                  const success = renderAllPlans();
                  if (success) {
                    rendered = true;
                    console.log('‚úÖ Plans rendered (property setter detected)');
                  }
                }
              }, 10);
            }
          },
          configurable: true,
          enumerable: true
        });

        console.log('‚úÖ Set up toolOutput property watcher');
      } catch (e) {
        console.warn('Could not set up property watcher (this is OK, using polling instead):', e.message);
      }
    }

    // Try immediate render first
    console.log('üöÄ Attempting immediate render...');
    if (hasValidToolOutput()) {
      const success = renderAllPlans();
      if (success) {
        rendered = true;
        console.log('‚úÖ Plans rendered immediately!');
      }
    }

    // Start the permanent solution immediately
    setupToolOutputWatcher();
    watchForToolOutputChange();

    // Also try rendering after delays
    setTimeout(() => {
      if (!rendered && hasValidToolOutput()) {
        const success = renderAllPlans();
        if (success) {
          rendered = true;
          console.log('‚úÖ Plans rendered after short delay');
        }
      }
    }, 100);

    setTimeout(() => {
      if (!rendered && hasValidToolOutput()) {
        const success = renderAllPlans();
        if (success) {
          rendered = true;
          console.log('‚úÖ Plans rendered after 500ms delay');
        }
      }
    }, 500);

    setTimeout(() => {
      if (!rendered && hasValidToolOutput()) {
        const success = renderAllPlans();
        if (success) {
          rendered = true;
          console.log('‚úÖ Plans rendered after 1s delay');
        }
      }
    }, 1000);

    window.addEventListener("load", () => {
      console.log('üì• Load event fired, attempting to render plans');
      if (!rendered) {
        const success = renderAllPlans();
        if (success) {
          rendered = true;
          console.log('‚úÖ Plans rendered on load event');
        }
      }
    });

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        console.log('üì• DOMContentLoaded fired, attempting to render plans');
        if (!rendered) {
          const success = renderAllPlans();
          if (success) {
            rendered = true;
            console.log('‚úÖ Plans rendered on DOMContentLoaded');
          }
        }
      });
    } else {
      console.log('üì• DOM already loaded, attempting immediate render');
      if (!rendered) {
        const success = renderAllPlans();
        if (success) {
          rendered = true;
          console.log('‚úÖ Plans rendered (DOM already loaded)');
        }
      }
    }
  </script>
</body>

</html>
