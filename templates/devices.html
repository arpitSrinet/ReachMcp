<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Devices</title>
  <meta http-equiv="Content-Security-Policy"
    content="img-src 'self' data: https://shopware-api-nctc-qa.reachmobileplatform.com https://cdn.tailwindcss.com https://cdn.jsdelivr.net https://unpkg.com https://*.oaiusercontent.com https://threejs.org;">
  <style>
    :root {
      --primary-green: #30ba95;
      --primary-green-hover: #269678;
      --card-radius: 24px;
      --button-radius: 999px;
      --button-padding: 14px 22px;
      --cta-bg: #000000;
      --cta-bg-hover: #121212;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
      padding: 24px;
      background: #f3f4f6;
    }

    .devices-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(340px, 1fr));
      gap: 28px;
      max-width: 1400px;
      margin: 0 auto;
    }

    .device-card {
      border: 1px solid #e0e0e0;
      border-radius: var(--card-radius);
      padding: 24px;
      background: #ffffff;
      box-shadow: 0 12px 30px rgba(15, 23, 42, 0.12);
      transition: all 0.25s ease;
      display: flex;
      flex-direction: column;
    }

    .device-card:hover {
      box-shadow: 0 18px 40px rgba(15, 23, 42, 0.18);
      transform: translateY(-4px);
      border-color: #d0d0d0;
    }

    .device-brand {
      font-size: 14px;
      color: #6b7280;
      margin-bottom: 6px;
      font-weight: 500;
      text-transform: capitalize;
      letter-spacing: 0.02em;
    }

    .device-name {
      font-size: 20px;
      font-weight: 600;
      color: #111827;
      margin-bottom: 4px;
      line-height: 1.35;
    }

    .device-condition {
      font-size: 13px;
      color: #6b7280;
      margin-bottom: 16px;
      font-weight: 400;
      text-transform: capitalize;
    }

    .device-gallery {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 18px;
    }

    .device-image-container {
      width: 100%;
      height: 230px;
      background: linear-gradient(145deg, #f9fafb 0%, #e5e7eb 100%);
      border-radius: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
      padding: 12px;
    }

    .device-image {
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: transparent;
    }

    .device-image-placeholder {
      width: 120px;
      height: 120px;
      background: #e5e7eb;
      border-radius: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 48px;
      color: #9ca3af;
    }

    .device-image-wrapper {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .device-image-nav-btn {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      width: 32px;
      height: 32px;
      border-radius: 999px;
      border: none;
      background: rgba(255, 255, 255, 0.9);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 18px;
      font-weight: 600;
      color: #111827;
      transition: all 0.2s ease;
      z-index: 2;
    }

    .device-image-nav-btn--left {
      left: 12px;
    }

    .device-image-nav-btn--right {
      right: 12px;
    }

    .device-image-nav-btn:hover {
      background: #111827;
      color: #ffffff;
      transform: translateY(-50%) scale(1.05);
      box-shadow: 0 6px 14px rgba(0, 0, 0, 0.3);
    }

    .device-pricing {
      margin-bottom: 10px;
    }

    .price-row {
      display: flex;
      align-items: baseline;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 4px;
    }

    .original-price {
      font-size: 16px;
      color: #9ca3af;
      text-decoration: line-through;
      font-weight: 400;
    }

    .current-price {
      font-size: 24px;
      font-weight: 700;
      color: #111827;
      letter-spacing: -0.02em;
    }

    .discount-badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: #30ba95;
      color: white;
      padding: 4px 12px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }

    .financing-option {
      font-size: 13px;
      color: #4b5563;
      margin-bottom: 18px;
      line-height: 1.6;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .financing-logo {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      height: 18px;
      margin-left: 4px;
    }

    .financing-logo img {
      display: inline-block;
      height: 18px;
      width: auto;
      max-width: 100px;
      object-fit: contain;
      vertical-align: middle;
    }

    .financing-logo img[src=""] {
      display: none;
    }

    .financing-logo svg {
      display: inline-block;
      height: 18px;
      width: auto;
      max-width: 120px;
      vertical-align: middle;
      flex-shrink: 0;
    }

    .add-to-cart-btn {
      width: 100%;
      background: var(--cta-bg);
      color: white;
      border: none;
      border-radius: var(--button-radius);
      padding: var(--button-padding);
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      margin-top: auto;
    }

    .add-to-cart-btn:hover {
      background: var(--cta-bg-hover);
      transform: translateY(-1px);
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.25);
    }

    .add-to-cart-btn:active {
      transform: translateY(0);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    }

    .add-to-cart-btn--added {
      background: #30ba95;
    }

    .add-to-cart-btn--added:hover {
      background: #30ba95;
      box-shadow: 0 10px 20px rgba(48, 186, 149, 0.35);
    }

    .line-selection-section {
      margin-top: 16px;
      padding: 16px;
      background: #f9fafb;
      border-radius: 12px;
      display: none;
      position: relative;
      z-index: 10;
    }

    .line-selection-section.show {
      display: block;
    }

    .line-selection-title {
      font-size: 14px;
      font-weight: 600;
      color: #111827;
      margin-bottom: 12px;
    }

    .line-checkboxes {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .line-checkbox-item {
      display: flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
      padding: 8px;
      border-radius: 8px;
      transition: background 0.2s ease;
    }

    .line-checkbox-item:hover {
      background: #f3f4f6;
    }

    .line-checkbox-item.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .line-checkbox-item.disabled:hover {
      background: transparent;
    }

    .line-checkbox {
      position: relative;
      width: 24px;
      height: 24px;
      flex-shrink: 0;
    }

    .line-checkbox input[type="checkbox"] {
      position: absolute;
      opacity: 0;
      cursor: pointer;
      width: 100%;
      height: 100%;
      margin: 0;
    }

    .line-checkbox-custom {
      width: 24px;
      height: 24px;
      border: 2px solid #d1d5db;
      border-radius: 50%;
      background: white;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    .line-checkbox input[type="checkbox"]:checked+.line-checkbox-custom {
      background: var(--primary-green);
      border-color: var(--primary-green);
    }

    .line-checkbox input[type="checkbox"]:checked+.line-checkbox-custom::after {
      content: '‚úì';
      color: white;
      font-size: 14px;
      font-weight: bold;
    }

    .line-checkbox input[type="checkbox"]:disabled+.line-checkbox-custom {
      background: #e5e7eb;
      border-color: #d1d5db;
      cursor: not-allowed;
    }

    .line-label {
      font-size: 14px;
      color: #111827;
      font-weight: 500;
    }

    .line-label.occupied {
      color: #9ca3af;
      font-style: italic;
    }

    .setup-lines-section {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: #fef2f2;
      border-top: 2px solid #fee2e2;
      padding: 24px;
      box-shadow: 0 -4px 20px rgba(220, 38, 38, 0.1);
      z-index: 101;
      display: none;
      text-align: center;
    }

    .setup-lines-section.show {
      display: block;
    }

    .setup-lines-title {
      font-size: 16px;
      font-weight: 700;
      color: #991b1b;
      margin-bottom: 8px;
    }

    .setup-lines-text {
      font-size: 14px;
      color: #b91c1c;
      margin-bottom: 16px;
    }

    .setup-lines-button {
      background: #dc2626;
      color: white;
      border: none;
      padding: 12px 32px;
      border-radius: var(--button-radius);
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .setup-lines-button:hover {
      background: #b91c1c;
      transform: translateY(-1px);
      box-shadow: 0 8px 16px rgba(220, 38, 38, 0.3);
    }

    .global-confirm-section {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: white;
      border-top: 1px solid #e0e0e0;
      padding: 20px 24px;
      box-shadow: 0 -4px 20px rgba(15, 23, 42, 0.1);
      z-index: 100;
      display: none;
      transition: transform 0.3s ease;
    }

    .global-confirm-section.show {
      display: block;
    }

    .global-confirm-content {
      max-width: 1400px;
      margin: 0 auto;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 20px;
    }

    .global-confirm-summary {
      flex: 1;
      font-size: 14px;
      color: #111827;
    }

    .global-confirm-summary-title {
      font-weight: 600;
      margin-bottom: 4px;
    }

    .global-confirm-summary-details {
      color: #6b7280;
      font-size: 13px;
    }

    .global-confirm-button {
      background: var(--primary-green);
      color: white;
      border: none;
      padding: 14px 32px;
      border-radius: var(--button-radius);
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      white-space: nowrap;
    }

    .global-confirm-button:hover:enabled {
      background: var(--primary-green-hover);
      transform: translateY(-1px);
      box-shadow: 0 10px 20px rgba(48, 186, 149, 0.35);
    }

    .global-confirm-button:disabled {
      background: #d1d5db;
      color: #9ca3af;
      cursor: not-allowed;
      opacity: 0.6;
    }

    body {
      padding-bottom: 120px;
    }

    .devices-container {
      margin-bottom: 120px;
    }

    .device-specs {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid #e0e0e0;
      font-size: 13px;
      color: #666;
    }

    .specs-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px 16px;
      margin-top: 8px;
    }

    .spec-item {
      display: flex;
      flex-direction: column;
    }

    .spec-label {
      font-weight: 600;
      color: #30ba95;
      font-size: 12px;
      margin-bottom: 2px;
    }

    .spec-value {
      color: #455a64;
      font-size: 13px;
    }

    .device-meta {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid #f0f0f0;
      font-size: 11px;
      color: #999;
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 8px;
    }

    .stock-info {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 12px;
      font-weight: 500;
    }

    .stock-available {
      color: #30ba95;
    }

    .stock-low {
      color: #ff9800;
    }

    .stock-out {
      color: #d32f2f;
    }

    /* Filter Styles - Enhanced Elegant Design */
    .filters-container {
      max-width: 1400px;
      margin: 0 auto 32px;
      background: linear-gradient(145deg, #ffffff 0%, #f9fafb 100%);
      padding: 28px 32px;
      border-radius: var(--card-radius);
      box-shadow: 0 12px 30px rgba(15, 23, 42, 0.12);
      border: 1px solid rgba(224, 224, 224, 0.5);
      transition: all 0.3s ease;
    }

    .filters-container:hover {
      box-shadow: 0 18px 40px rgba(15, 23, 42, 0.18);
    }

    .filters-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 24px;
      padding-bottom: 16px;
      border-bottom: 2px solid #f0f0f0;
    }

    .filters-title {
      font-size: 22px;
      font-weight: 700;
      color: #111827;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .filters-title::before {
      content: 'üîç';
      font-size: 24px;
    }

    .filters-actions {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .clear-filters-btn {
      background: linear-gradient(145deg, #f5f5f5 0%, #e5e5e5 100%);
      color: #666;
      border: 1px solid #e0e0e0;
      border-radius: var(--button-radius);
      padding: 10px 20px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.25s ease;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .clear-filters-btn:hover {
      background: linear-gradient(145deg, #e5e5e5 0%, #d5d5d5 100%);
      border-color: #d0d0d0;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    .clear-filters-btn:active {
      transform: translateY(0);
    }

    .filters-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 20px;
      align-items: end;
    }

    .filter-group {
      display: flex;
      flex-direction: column;
      gap: 10px;
      position: relative;
    }

    .filter-label {
      font-size: 13px;
      font-weight: 600;
      color: #6b7280;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .filter-label::before {
      content: '';
      width: 3px;
      height: 14px;
      background: var(--primary-green);
      border-radius: 2px;
    }

    .filter-input,
    .filter-select {
      width: 100%;
      padding: 14px 16px;
      border: 2px solid #e5e7eb;
      border-radius: 12px;
      font-size: 15px;
      font-family: inherit;
      background: white;
      transition: all 0.25s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.02);
    }

    .filter-input:focus,
    .filter-select:focus {
      outline: none;
      border-color: var(--primary-green);
      box-shadow: 0 0 0 4px rgba(48, 186, 149, 0.1);
      transform: translateY(-1px);
    }

    .filter-input::placeholder {
      color: #9ca3af;
    }

    .filter-select {
      cursor: pointer;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%236b7280' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 16px center;
      padding-right: 40px;
    }

    .filter-checkbox-group {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 14px 18px;
      border: 2px solid #e5e7eb;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.25s ease;
      background: white;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.02);
    }

    .filter-checkbox-group:hover {
      border-color: var(--primary-green);
      background: linear-gradient(145deg, #f0fdf4 0%, #ffffff 100%);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(48, 186, 149, 0.15);
    }

    .filter-checkbox-group:has(input:checked) {
      border-color: var(--primary-green);
      background: linear-gradient(145deg, #ecfdf5 0%, #f0fdf4 100%);
    }

    .filter-checkbox-group input[type="checkbox"] {
      width: 20px;
      height: 20px;
      cursor: pointer;
      accent-color: var(--primary-green);
      flex-shrink: 0;
    }

    .filter-checkbox-group label {
      cursor: pointer;
      font-size: 15px;
      color: #111827;
      font-weight: 500;
      user-select: none;
      flex: 1;
    }

    .filter-results {
      font-size: 14px;
      color: #6b7280;
      margin-top: 20px;
      padding-top: 20px;
      border-top: 2px solid #f0f0f0;
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 12px;
    }

    .filter-results-count {
      font-weight: 600;
      color: #111827;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .filter-results-count::before {
      content: 'üìä';
      font-size: 16px;
    }

    .no-results {
      text-align: center;
      padding: 60px 20px;
      color: #6b7280;
    }

    .no-results-icon {
      font-size: 64px;
      margin-bottom: 16px;
      opacity: 0.5;
    }

    .no-results-title {
      font-size: 22px;
      font-weight: 600;
      margin-bottom: 8px;
      color: #111827;
    }

    .no-results-text {
      font-size: 15px;
      margin-bottom: 24px;
      color: #6b7280;
    }

    .filter-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: var(--primary-green);
      color: white;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 600;
      margin-left: 8px;
    }

    @media (max-width: 768px) {
      .filters-container {
        padding: 20px;
      }

      .filters-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 16px;
      }

      .filters-grid {
        grid-template-columns: 1fr;
        gap: 16px;
      }

      .filter-results {
        flex-direction: column;
        align-items: flex-start;
      }
    }
  </style>
</head>

<body>
  <!-- Filters Container -->
  <div class="filters-container" id="filters-container" style="display: none;">
    <div class="filters-title">üîç Filter Devices</div>
    <div class="filters-grid">
      <div class="filter-group">
        <label class="filter-label">Search</label>
        <input type="text" class="filter-input" id="filter-search" placeholder="Search by name or brand...">
      </div>
      <div class="filter-group">
        <label class="filter-label">Brand</label>
        <select class="filter-select" id="filter-brand">
          <option value="">All Brands</option>
        </select>
      </div>
      <div class="filter-group">
        <label class="filter-label">Max Price ($)</label>
        <input type="number" class="filter-input" id="filter-price" placeholder="No limit" min="0" step="100">
      </div>
      <div class="filter-group">
        <div class="filter-checkbox-group" onclick="toggleEsimFilter()">
          <input type="checkbox" id="filter-esim">
          <label for="filter-esim">eSIM Capable Only</label>
        </div>
      </div>
    </div>
    <div class="filter-results" id="filter-results">
      <div class="filter-results-count" id="filter-results-count">Showing all devices</div>
    </div>
  </div>

  <div class="devices-container" id="devices-container">
    <p style="padding: 20px; text-align: center; color: #666;">Loading devices...</p>
  </div>

  <div class="global-confirm-section" id="global-confirm-section">
    <div class="global-confirm-content">
      <div class="global-confirm-summary">
        <div class="global-confirm-summary-title" id="global-confirm-title">Ready to confirm</div>
        <div class="global-confirm-summary-details" id="global-confirm-details">Select devices for all lines to continue
        </div>
      </div>
      <button class="global-confirm-button" id="global-confirm-button" onclick="confirmAllSelections()" disabled>
        Confirm All Selections
      </button>
    </div>
  </div>

  <div class="setup-lines-section" id="setup-lines-section">
    <div class="setup-lines-title">üì¶ Lines Required First</div>
    <div class="setup-lines-text">You need to configure your lines before you can select devices.</div>
    <button class="setup-lines-button" id="setup-lines-button" onclick="sendPrompt('I want to set up my lines')">
      Set Up Lines Now
    </button>
  </div>

  <script>
    // Immediate diagnostic check
    console.log('üîç Devices widget initializing...', {
      hasOpenAI: typeof window.openai !== 'undefined',
      toolOutput: window.openai?.toolOutput,
      toolOutputType: typeof window.openai?.toolOutput,
      allKeys: window.openai ? Object.keys(window.openai) : []
    });

    // Track selected devices
    const selectedDevices = new Set();

    // Track line-to-device assignments: { lineId: deviceId }
    const lineDeviceAssignments = {};

    // Track device names: { deviceId: deviceName }
    const deviceNames = {};

    // Track which devices have been selected (for showing checkboxes)
    const devicesWithSelection = new Set();

    // Initialize currentLines - will be populated from toolOutput
    let currentLines = [];
    // Track lines that already have devices in cart
    let linesWithDevices = [];

    // Wrapper to extract lines and also get linesWithDevices
    function extractLines() {
      const toolOutput = window.openai ? window.openai.toolOutput : null;
      if (toolOutput && toolOutput.structuredContent && toolOutput.structuredContent.linesWithDevices) {
        linesWithDevices = toolOutput.structuredContent.linesWithDevices;
        console.log('‚úÖ Found linesWithDevices:', linesWithDevices);
      } else {
        linesWithDevices = [];
      }

      return extractLinesInternal();
    }

    // Function to extract lines from toolOutput
    function extractLinesInternal() {
      if (!window.openai) {
        console.log('‚ùå window.openai not available for lines');
        return [];
      }

      let toolOutput = window.openai.toolOutput;
      console.log('üîç Checking toolOutput for lines:', {
        exists: !!toolOutput,
        isNull: toolOutput === null,
        type: typeof toolOutput,
        keys: toolOutput ? Object.keys(toolOutput) : []
      });

      if (toolOutput && toolOutput !== null && typeof toolOutput === 'object') {
        // Check structuredContent first (this is where server.js puts the data)
        if (toolOutput.structuredContent) {
          if (toolOutput.structuredContent.lines && Array.isArray(toolOutput.structuredContent.lines) && toolOutput.structuredContent.lines.length > 0) {
            console.log('‚úÖ Found lines in toolOutput.structuredContent.lines:', toolOutput.structuredContent.lines.length);
            return toolOutput.structuredContent.lines.map((line, index) => ({
              id: line.lineNumber || (index + 1),
              lineNumber: line.lineNumber || (index + 1),
              name: `Line ${line.lineNumber || (index + 1)}`,
              phoneNumber: line.phoneNumber || null,
              deviceSelected: line.deviceSelected || false,
              deviceId: line.deviceId || null
            }));
          }

          if (toolOutput.structuredContent.lineCount && toolOutput.structuredContent.lineCount > 0) {
            console.log('‚úÖ Found lineCount in structuredContent, creating lines:', toolOutput.structuredContent.lineCount);
            const lines = [];
            for (let i = 1; i <= toolOutput.structuredContent.lineCount; i++) {
              lines.push({
                id: i,
                lineNumber: i,
                name: `Line ${i}`,
                phoneNumber: null,
                deviceSelected: false,
                deviceId: null
              });
            }
            return lines;
          }
        }

        // Check for lines directly
        if (toolOutput.lines && Array.isArray(toolOutput.lines) && toolOutput.lines.length > 0) {
          console.log('‚úÖ Found lines in toolOutput.lines:', toolOutput.lines.length);
          return toolOutput.lines.map((line, index) => ({
            id: line.lineNumber || (index + 1),
            lineNumber: line.lineNumber || (index + 1),
            name: `Line ${line.lineNumber || (index + 1)}`,
            phoneNumber: line.phoneNumber || null,
            deviceSelected: line.deviceSelected || false,
            deviceId: line.deviceId || null
          }));
        }

        // Check for flowContext with lines
        if (toolOutput.flowContext && toolOutput.flowContext.lines && Array.isArray(toolOutput.flowContext.lines)) {
          console.log('‚úÖ Found lines in toolOutput.flowContext.lines:', toolOutput.flowContext.lines.length);
          return toolOutput.flowContext.lines.map((line, index) => ({
            id: line.lineNumber || (index + 1),
            lineNumber: line.lineNumber || (index + 1),
            name: `Line ${line.lineNumber || (index + 1)}`,
            phoneNumber: line.phoneNumber || null,
            deviceSelected: line.deviceSelected || false,
            deviceId: line.deviceId || null
          }));
        }

        // Check for lineCount and create lines from it
        if (toolOutput.lineCount && toolOutput.lineCount > 0) {
          console.log('‚úÖ Found lineCount in toolOutput, creating lines:', toolOutput.lineCount);
          const lines = [];
          for (let i = 1; i <= toolOutput.lineCount; i++) {
            lines.push({
              id: i,
              lineNumber: i,
              name: `Line ${i}`,
              phoneNumber: null,
              deviceSelected: false,
              deviceId: null
            });
          }
          return lines;
        }
      }

      const metadata = window.openai.toolResponseMetadata;
      if (metadata && metadata !== null && typeof metadata === 'object') {
        if (metadata.lines && Array.isArray(metadata.lines)) {
          console.log('‚úÖ Found lines in toolResponseMetadata.lines:', metadata.lines.length);
          return metadata.lines.map((line, index) => ({
            id: line.lineNumber || (index + 1),
            lineNumber: line.lineNumber || (index + 1),
            name: `Line ${line.lineNumber || (index + 1)}`,
            phoneNumber: line.phoneNumber || null,
            deviceSelected: line.deviceSelected || false,
            deviceId: line.deviceId || null
          }));
        }

        if (metadata.lineCount && metadata.lineCount > 0) {
          console.log('‚úÖ Found lineCount in metadata, creating lines:', metadata.lineCount);
          const lines = [];
          for (let i = 1; i <= metadata.lineCount; i++) {
            lines.push({
              id: i,
              lineNumber: i,
              name: `Line ${i}`,
              phoneNumber: null,
              deviceSelected: false,
              deviceId: null
            });
          }
          return lines;
        }
      }

      console.log('‚ùå No lines found in any location');
      return [];
    }

    // Function to render a single device card
    function renderDevice(device) {
      const deviceId = device.id || device.productNumber || device.ean || 'unknown';

      // Get brand from API
      let brand = device.manufacturer?.name || device.brand || device.translated?.manufacturer?.name || '';

      // Get device name
      let name = device.name || device.translated?.name || 'Unknown Device';

      // Extract brand from device name if it starts with brand name
      // Example: "Google Pixel 9 Pro XL" -> brand: "Google", name: "Pixel 9 Pro XL"
      if (brand && name.toLowerCase().startsWith(brand.toLowerCase())) {
        // Remove brand from the beginning of name
        name = name.substring(brand.length).trim();
      } else if (!brand && name) {
        // If no brand from API, try to extract from name (first word)
        const nameParts = name.split(' ');
        if (nameParts.length > 1) {
          brand = nameParts[0];
          name = nameParts.slice(1).join(' ');
        }
      }

      // Fallback if brand is still empty
      if (!brand) {
        brand = 'Unknown Brand';
      }

      // Extract properties (Storage, Color, Condition, etc.)
      const properties = device.properties || [];
      const storage = properties.find(p => p.group?.name === 'Storage')?.name || '';
      const color = properties.find(p => p.group?.name === 'Color')?.name || '';
      const condition = properties.find(p => p.group?.name === 'Condition')?.name ||
        device.condition ||
        device.customFields?.condition ||
        '';
      const fullName = storage ? `${name} (${storage})` : name;

      // Pricing
      const calculatedPrice = device.calculatedPrice || device.calculatedCheapestPrice;
      const currentPrice = calculatedPrice?.unitPrice || calculatedPrice?.totalPrice || device.price?.[0]?.gross || 0;
      const listPrice = calculatedPrice?.listPrice?.price || device.price?.[0]?.listPrice || device.listPrice || null;
      const originalPrice = listPrice;

      // Calculate discount
      let discountPctg = 0;
      if (originalPrice && originalPrice > currentPrice) {
        discountPctg = Math.round(((originalPrice - currentPrice) / originalPrice) * 100);
      } else if (calculatedPrice?.listPrice?.percentage) {
        discountPctg = Math.round(calculatedPrice.listPrice.percentage);
      }

      // Format prices
      const formattedCurrentPrice = currentPrice.toLocaleString('en-US', {
        style: 'currency',
        currency: 'USD',
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
      });
      const formattedOriginalPrice = originalPrice ? originalPrice.toLocaleString('en-US', {
        style: 'currency',
        currency: 'USD',
        minimumFractionDigits: 0,
        maximumFractionDigits: 0
      }) : null;

      // Images (cover + gallery + description HTML)
      const imageCandidates = [];
      if (device.cover?.media?.url) {
        imageCandidates.push(device.cover.media.url);
      }
      if (Array.isArray(device.media)) {
        device.media.forEach(m => {
          const url = m?.media?.url || m?.url;
          if (url) imageCandidates.push(url);
        });
      }
      if (device.image) {
        imageCandidates.push(device.image);
      }
      // Extract <img src="..."> URLs from description HTML (translated or raw)
      const descriptionHtml = (typeof device.translated?.description === 'string'
        ? device.translated.description
        : (typeof device.description === 'string' ? device.description : '')
      );
      if (descriptionHtml) {
        try {
          const imgRegex = /<img[^>]+src=["']([^"']+)["'][^>]*>/gi;
          let match;
          while ((match = imgRegex.exec(descriptionHtml)) !== null) {
            if (match[1]) {
              imageCandidates.push(match[1]);
            }
          }
        } catch (e) {
          console.warn('Failed to parse image URLs from description HTML', e);
        }
      }
      const uniqueImages = Array.from(new Set(imageCandidates));
      const mainImage = uniqueImages[0] || null;

      // Financing (derive from price or use provided)
      const financingMonthly = device.financingMonthly ||
        device.financing?.monthlyPayment ||
        (currentPrice > 0 ? Math.round((currentPrice / 24) * 100) / 100 : 15.00);
      const financingProvider = device.financingProvider ||
        device.financing?.provider ||
        'TERRACE FINANCE';
      const formattedMonthly = financingMonthly.toLocaleString('en-US', {
        style: 'currency',
        currency: 'USD',
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
      });
      // Basic availability (used only for CTA enabled/disabled)
      const stock = device.stock;
      const isAvailable = device.available !== false && (stock === undefined || stock > 0);
      const galleryId = `gallery-${deviceId}`;

      return `
        <div class="device-card">
          <div class="device-brand">${brand}</div>
          <div class="device-name">${fullName}</div>
          ${condition && condition.toLowerCase() !== 'new' ? `<div class="device-condition">${condition}</div>` : ''}

          <div class="device-gallery"
               data-gallery-id="${galleryId}"
               data-images='${JSON.stringify(uniqueImages)}'
               data-current-index="0">
            <div class="device-image-wrapper">
              ${uniqueImages.length > 1 ? `
              <button type="button"
                      class="device-image-nav-btn device-image-nav-btn--left"
                      onclick="stepDeviceImage('${galleryId}', -1)"
                      aria-label="Previous image">
                ‚Äπ
              </button>
              ` : ''}
              <div class="device-image-container">
                ${(device.base64Image || device.localImageUrl || mainImage) ?
          `<img src="${device.base64Image || device.localImageUrl || mainImage}" alt="${name}" class="device-image device-image-main" data-fallback-index="0" data-fallbacks='${JSON.stringify([device.localImageUrl, mainImage].filter(Boolean))}' onerror="handleDeviceImageEnhancedError(this)">` :
          `<div class="device-image-placeholder">üì±</div>`
        }
              </div>
              ${uniqueImages.length > 1 ? `
              <button type="button"
                      class="device-image-nav-btn device-image-nav-btn--right"
                      onclick="stepDeviceImage('${galleryId}', 1)"
                      aria-label="Next image">
                ‚Ä∫
              </button>
              ` : ''}
            </div>
          </div>
          
          <div class="device-pricing">
            <div class="price-row">
              ${formattedOriginalPrice ? `<span class="original-price">${formattedOriginalPrice}</span>` : ''}
              <span class="current-price">${formattedCurrentPrice}</span>
              ${discountPctg > 0 ? `<span class="discount-badge">${discountPctg}% OFF</span>` : ''}
            </div>
          </div>
          
          <div class="financing-option">
            <span>or as low as <strong>${formattedMonthly}/mo</strong> with</span>
            <span class="financing-logo">
              <svg width="120" height="30" viewBox="0 0 120 30" xmlns="http://www.w3.org/2000/svg" aria-label="${financingProvider} logo">
                <text x="0" y="12" font-family="Arial, sans-serif" font-size="11" font-weight="bold" fill="#1e3a8a">TERRACE</text>
                <text x="0" y="25" font-family="Arial, sans-serif" font-size="10" font-weight="normal" fill="#000000">FINANCE</text>
                <g transform="translate(65, 4)">
                  <rect x="0" y="0" width="12" height="2.5" rx="1.25" fill="#2563eb"/>
                  <rect x="2" y="5" width="18" height="2.5" rx="1.25" fill="#2563eb"/>
                  <rect x="4" y="10" width="24" height="2.5" rx="1.25" fill="#2563eb"/>
                </g>
              </svg>
            </span>
          </div>

          <button class="add-to-cart-btn ${selectedDevices.has(deviceId) ? 'add-to-cart-btn--added' : ''}" 
                  onclick="selectDevice('${deviceId}', '${name.replace(/'/g, "\\'")}', this)" 
                  ${!isAvailable || currentLines.length === 0 ? 'disabled style="opacity: 0.5; cursor: not-allowed;"' : ''}>
            ${!isAvailable ? 'Out of Stock' : (currentLines.length === 0 ? 'Setup Lines First' : (selectedDevices.has(deviceId) ? '‚úì Selected' : 'Select Device'))}
          </button>
          
          <div class="line-selection-section ${devicesWithSelection.has(deviceId) ? 'show' : ''}" id="line-selection-${deviceId}">
            <div class="line-selection-title">Select lines for this device:</div>
            <div class="line-checkboxes">
              ${currentLines.map(line => {
          const lineIdStr = String(line.id);
          const hasDeviceInCart = linesWithDevices.includes(line.id);
          const isChecked = lineDeviceAssignments[lineIdStr] === deviceId;
          // Line is assigned to another device in this widget session
          const isLineAssignedToOther = lineDeviceAssignments[lineIdStr] && !isChecked;
          // Line already has a device assigned in the cart (from tool data)
          const isLineOccupiedInCart = line.deviceSelected === true || hasDeviceInCart;

          const isDisabled = isLineAssignedToOther || isLineOccupiedInCart;

          return `
                  <label class="line-checkbox-item ${isDisabled ? 'disabled' : ''}" ${isDisabled ? 'onclick="return false;"' : ''}>
                    <div class="line-checkbox">
                      <input type="checkbox" 
                             id="line-${line.id}-device-${deviceId}"
                             ${isChecked ? 'checked' : ''}
                             ${isDisabled ? 'disabled' : ''}
                             onchange="toggleDeviceLineAssignment(${line.id}, '${deviceId}', '${name.replace(/'/g, "\\'")}')">
                      <span class="line-checkbox-custom"></span>
                    </div>
                    <span class="line-label ${isLineOccupiedInCart ? 'occupied' : ''}">
                      ${line.name} ${line.phoneNumber ? `(${line.phoneNumber})` : ''}
                      ${isLineOccupiedInCart ? ' (Device in cart)' : ''}
                    </span>
                  </label>
                `;
        }).join('')}
            </div>
          </div>
        </div>
      `;
    }

    // Shared helper function to populate chat input with prompt
    function sendPrompt(message) {
      if (!message) {
        console.error('sendPrompt called without message');
        return;
      }

      console.log('sendPrompt called with:', message);

      // Try openPromptInput first (populates input field)
      if (window.openai?.openPromptInput) {
        try {
          window.openai.openPromptInput(message);
          console.log('‚úÖ Prompt added to chat input:', message);
          return;
        } catch (e) {
          console.error('Error with openPromptInput:', e);
        }
      }

      // Fallback to sendFollowUpMessage (sends immediately)
      if (window.openai?.sendFollowUpMessage) {
        try {
          // Ensure message is a string
          const promptText = String(message);
          // Try calling with object format first
          if (typeof window.openai.sendFollowUpMessage === 'function') {
            // Check if it expects an object with 'prompt' property
            const result = window.openai.sendFollowUpMessage({ prompt: promptText });
            console.log('‚úÖ Prompt sent via sendFollowUpMessage (object):', promptText);
            return;
          }
        } catch (e) {
          // If object format fails, try string format
          try {
            window.openai.sendFollowUpMessage(promptText);
            console.log('‚úÖ Prompt sent via sendFollowUpMessage (string):', promptText);
            return;
          } catch (e2) {
            console.error('Error with sendFollowUpMessage (both formats):', e, e2);
          }
        }
      }

      // Last resort: show alert
      console.error('No prompt API available. Available keys:', window.openai ? Object.keys(window.openai) : 'window.openai not found');
      alert(`Action: ${message}\n\nPlease type this in the chat and press Enter.`);
    }

    // Make functions available globally
    window.sendPrompt = sendPrompt;
    window.clearFilters = clearFilters;
    window.toggleEsimFilter = toggleEsimFilter;
    window.stepDeviceImage = stepDeviceImage;
    window.replaceLogoWithSVG = replaceLogoWithSVG;
    window.selectDevice = selectDevice;
    window.toggleDeviceLineAssignment = toggleDeviceLineAssignment;
    window.confirmAllSelections = confirmAllSelections;

    function selectDevice(deviceId, deviceName, buttonEl) {
      const isSelected = selectedDevices.has(deviceId);

      if (isSelected) {
        // Deselect
        selectedDevices.delete(deviceId);
        devicesWithSelection.delete(deviceId);

        // Remove device name
        delete deviceNames[deviceId];

        // Remove all line assignments for this device
        Object.keys(lineDeviceAssignments).forEach(lineId => {
          if (lineDeviceAssignments[lineId] === deviceId) {
            delete lineDeviceAssignments[lineId];
            // Also uncheck the checkbox if it exists
            const checkbox = document.getElementById(`line-${lineId}-device-${deviceId}`);
            if (checkbox) {
              checkbox.checked = false;
            }
          }
        });

        if (buttonEl) {
          buttonEl.classList.remove('add-to-cart-btn--added');
          buttonEl.textContent = 'Select Device';
        }

        // Hide line selection section
        const lineSection = document.getElementById(`line-selection-${deviceId}`);
        if (lineSection) {
          lineSection.classList.remove('show');
        }

        // Re-render all devices to update disabled states
        renderAllDevices();
      } else {
        // Select
        selectedDevices.add(deviceId);
        devicesWithSelection.add(deviceId);

        // Store device name for later use
        deviceNames[deviceId] = deviceName;

        if (buttonEl) {
          buttonEl.classList.add('add-to-cart-btn--added');
          buttonEl.textContent = '‚úì Selected';
        }

        // Show line selection section
        const lineSection = document.getElementById(`line-selection-${deviceId}`);
        if (lineSection) {
          lineSection.classList.add('show');
        }

        // Re-render all devices to update disabled states
        renderAllDevices();
      }

      updateConfirmButtons();
    }

    function toggleDeviceLineAssignment(lineId, deviceId, deviceName) {
      // Ensure lineId is a string for consistent key usage
      const lineIdStr = String(lineId);
      const checkbox = document.getElementById(`line-${lineId}-device-${deviceId}`);
      if (!checkbox) return;

      const isChecked = checkbox.checked;

      console.log('üîÑ toggleDeviceLineAssignment:', { lineId, lineIdStr, deviceId, isChecked, currentAssignments: Object.assign({}, lineDeviceAssignments) });

      if (isChecked) {
        // If this line already has a device assigned, remove it first
        if (lineDeviceAssignments[lineIdStr] && lineDeviceAssignments[lineIdStr] !== deviceId) {
          const oldDeviceId = lineDeviceAssignments[lineIdStr];
          // Uncheck the old device's checkbox for this line
          const oldCheckbox = document.getElementById(`line-${lineId}-device-${oldDeviceId}`);
          if (oldCheckbox) {
            oldCheckbox.checked = false;
          }
        }

        // Assign this device to this line
        lineDeviceAssignments[lineIdStr] = deviceId;
      } else {
        // Remove assignment
        if (lineDeviceAssignments[lineIdStr] === deviceId) {
          delete lineDeviceAssignments[lineIdStr];
        }
      }

      console.log('‚úÖ toggleDeviceLineAssignment complete:', { lineDeviceAssignments: Object.assign({}, lineDeviceAssignments) });

      // Re-render all devices to update disabled states
      renderAllDevices();
      updateConfirmButtons();
    }

    function updateConfirmButtons() {
      // Update current lines from toolOutput
      const extractedLines = extractLines();
      if (extractedLines.length > 0) {
        currentLines = extractedLines;
        console.log('‚úÖ updateConfirmButtons: Lines updated:', currentLines.length, currentLines);
      }

      // Check if no lines are set up
      const noLinesConfigured = currentLines.length === 0;
      const setupSection = document.getElementById('setup-lines-section');
      const globalConfirmSection = document.getElementById('global-confirm-section');

      if (setupSection) {
        if (noLinesConfigured) {
          setupSection.classList.add('show');
          if (globalConfirmSection) globalConfirmSection.classList.remove('show');

          const container = document.getElementById('devices-container');
          if (container) container.style.paddingBottom = '160px';
          return;
        } else {
          setupSection.classList.remove('show');
        }
      }

      // Get all device-to-line assignments
      const assignments = [];
      currentLines.forEach(line => {
        const lineIdStr = String(line.id);
        const hasDeviceInCart = linesWithDevices.includes(line.id);

        if (lineDeviceAssignments[lineIdStr]) {
          assignments.push({
            lineId: line.id,
            lineName: line.name,
            deviceId: lineDeviceAssignments[lineIdStr]
          });
        } else if (hasDeviceInCart) {
          // Count lines with devices in cart as "assigned" for visual/logic purposes 
          // (though we don't need to add them to cart again)
          assignments.push({
            lineId: line.id,
            lineName: line.name,
            deviceId: 'IN_CART',
            inCart: true
          });
        }
      });

      console.log('‚úÖ updateConfirmButtons: State check', {
        totalLines: currentLines.length,
        assignedLines: assignments.length,
        lineDeviceAssignments: Object.assign({}, lineDeviceAssignments),
      });

      // Update global confirm section
      const globalConfirmButton = document.getElementById('global-confirm-button');
      const globalConfirmTitle = document.getElementById('global-confirm-title');
      const globalConfirmDetails = document.getElementById('global-confirm-details');

      if (globalConfirmSection && globalConfirmButton && globalConfirmTitle && globalConfirmDetails) {
        // Show section if there are any assignments
        if (assignments.length > 0) {
          globalConfirmSection.classList.add('show');

          const assignedLinesCount = assignments.length;
          const totalLinesCount = currentLines.length;

          // Relaxed logic: allow confirmation if at least one device is selected
          globalConfirmTitle.textContent = `${assignedLinesCount} ${assignedLinesCount === 1 ? 'device' : 'devices'} selected`;
          globalConfirmDetails.textContent = `Ready to add to cart (Devices are optional)`;
          globalConfirmButton.disabled = false;
        } else {
          globalConfirmSection.classList.remove('show');
          globalConfirmButton.disabled = true;
        }

        // Adjust container padding based on confirm section visibility
        const container = document.getElementById('devices-container');
        if (container) {
          if (globalConfirmSection.classList.contains('show')) {
            container.style.paddingBottom = '160px';
          } else {
            container.style.paddingBottom = '24px';
          }
        }
      }
    }

    function confirmAllSelections() {
      // Update current lines from toolOutput
      currentLines = extractLines();

      // Get all device-to-line assignments from all cards
      const allAssignments = [];

      currentLines.forEach(line => {
        const lineIdStr = String(line.id);
        if (lineDeviceAssignments[lineIdStr]) {
          const deviceId = lineDeviceAssignments[lineIdStr];
          const deviceName = deviceNames[deviceId] || `Device ${deviceId}`;

          allAssignments.push({
            lineId: line.id,
            lineNumber: line.lineNumber || line.id,
            lineName: line.name,
            deviceId: deviceId,
            deviceName: deviceName
          });
        }
      });

      if (allAssignments.length === 0) {
        // If we have devices in cart but no new selections, allow user to proceed/continue
        if (linesWithDevices.length > 0) {
          sendPrompt("I have completed my device selections.");
          return;
        }
        alert('Please select at least one device for a line.');
        return;
      }

      // Build individual add_to_cart commands for each device-line combination
      const commands = allAssignments.map(a => {
        return `Add ${a.deviceName} device (ID: ${a.deviceId}) to line ${a.lineNumber}`;
      });

      // Send all commands as a single message
      const message = `Please add the following devices to my cart:\n\n${commands.join('\n')}\n\nUse the add_to_cart tool with itemType="device", itemId for each device, and the corresponding lineNumber for each line.`;
      sendPrompt(message);

      console.log('‚úÖ Confirmed selections, sending to cart:', {
        assignments: allAssignments,
        commands: commands
      });
    }

    // Image gallery handler for each card (direct change)
    function changeDeviceImage(galleryId, imageUrl, index) {
      if (!galleryId || !imageUrl) return;

      const gallery = document.querySelector(`[data-gallery-id="${galleryId}"]`);
      if (!gallery) return;

      const mainImage = gallery.querySelector('.device-image-main');
      if (mainImage) {
        mainImage.src = imageUrl;
      }

      // Persist current index so arrows know where we are
      if (typeof index === 'number' && !Number.isNaN(index)) {
        gallery.setAttribute('data-current-index', String(index));
      }
    }

    // Image gallery handler for each card (step left/right)
    function stepDeviceImage(galleryId, direction) {
      if (!galleryId || !direction) return;

      const gallery = document.querySelector(`[data-gallery-id=\"${galleryId}\"]`);
      if (!gallery) return;

      const dataAttr = gallery.getAttribute('data-images');
      if (!dataAttr) return;

      let urls;
      try {
        urls = JSON.parse(dataAttr);
      } catch (e) {
        console.warn('Failed to parse image URLs from data-images', e);
        return;
      }

      if (!urls || !Array.isArray(urls) || urls.length === 0) return;

      const currentIndexRaw = gallery.getAttribute('data-current-index');
      let currentIndex = currentIndexRaw !== null ? parseInt(currentIndexRaw, 10) : 0;
      if (Number.isNaN(currentIndex) || currentIndex < 0 || currentIndex >= urls.length) {
        currentIndex = 0;
      }

      const nextIndex = (currentIndex + direction + urls.length) % urls.length;
      const nextUrl = urls[nextIndex];

      changeDeviceImage(galleryId, nextUrl, nextIndex);
    }

    // Function to check if toolOutput has valid data
    function hasValidToolOutput() {
      if (!window.openai) return false;

      const toolOutput = window.openai.toolOutput;
      if (toolOutput && toolOutput !== null && typeof toolOutput === 'object') {
        if (toolOutput.devices && Array.isArray(toolOutput.devices) && toolOutput.devices.length > 0) {
          return true;
        }
        if (toolOutput.structuredContent && toolOutput.structuredContent.devices &&
          Array.isArray(toolOutput.structuredContent.devices) && toolOutput.structuredContent.devices.length > 0) {
          return true;
        }
      }

      const metadata = window.openai.toolResponseMetadata;
      if (metadata && metadata !== null && typeof metadata === 'object') {
        if (metadata.devices && Array.isArray(metadata.devices) && metadata.devices.length > 0) {
          return true;
        }
      }

      return false;
    }

    // Function to extract devices from toolOutput
    function extractDevices() {
      if (!window.openai) {
        console.log('‚ùå window.openai not available');
        return [];
      }

      let toolOutput = window.openai.toolOutput;
      console.log('üîç Checking toolOutput:', {
        exists: !!toolOutput,
        isNull: toolOutput === null,
        type: typeof toolOutput,
        keys: toolOutput ? Object.keys(toolOutput) : []
      });

      if (toolOutput && toolOutput !== null && typeof toolOutput === 'object') {
        if (toolOutput.devices && Array.isArray(toolOutput.devices)) {
          console.log('‚úÖ Found devices in toolOutput.devices:', toolOutput.devices.length);
          return toolOutput.devices;
        }
        if (toolOutput.structuredContent && toolOutput.structuredContent.devices && Array.isArray(toolOutput.structuredContent.devices)) {
          console.log('‚úÖ Found devices in toolOutput.structuredContent.devices:', toolOutput.structuredContent.devices.length);
          return toolOutput.structuredContent.devices;
        }
      }

      const metadata = window.openai.toolResponseMetadata;
      if (metadata && metadata !== null && typeof metadata === 'object') {
        console.log('üîç Checking toolResponseMetadata:', Object.keys(metadata));
        if (metadata.devices && Array.isArray(metadata.devices)) {
          console.log('‚úÖ Found devices in toolResponseMetadata.devices:', metadata.devices.length);
          return metadata.devices;
        }
      }

      console.log('‚ùå No devices found in any location');
      return [];
    }

    // Store all devices for filtering
    let allDevices = [];

    // Filter functions
    function getDevicePrice(device) {
      // Try multiple price fields in order of preference
      if (device?.calculatedPrice?.unitPrice) return device.calculatedPrice.unitPrice;
      if (device?.calculatedPrice?.totalPrice) return device.calculatedPrice.totalPrice;
      if (device?.calculatedCheapestPrice?.unitPrice) return device.calculatedCheapestPrice.unitPrice;
      if (device?.calculatedCheapestPrice?.totalPrice) return device.calculatedCheapestPrice.totalPrice;
      if (device?.price?.[0]?.gross) return device.price[0].gross;
      if (typeof device?.price === 'number') return device.price;
      return 0;
    }

    function isEsimCapable(device) {
      if (!device) return false;

      // Check boolean/flag fields
      const flagCandidates = [
        device.esimAvailable,
        device.eSimAvailable,
        device.esimCapable,
        device.supportsEsim,
        device.esim_capable,
        device.eSIMCapable
      ];

      if (flagCandidates.some(v => v === true || v === "true" || v === "Y" || v === "YES")) {
        return true;
      }

      // Check properties array
      const props = device.properties || [];
      const propsText = JSON.stringify(props).toLowerCase();
      if (propsText.includes("esim") || propsText.includes("e-sim")) {
        return true;
      }

      // Check full device object
      const fullText = JSON.stringify(device).toLowerCase();
      return fullText.includes("esim") || fullText.includes("e-sim");
    }

    function filterDevices() {
      const searchQuery = document.getElementById('filter-search')?.value.toLowerCase().trim() || '';
      const brandFilter = document.getElementById('filter-brand')?.value || '';
      const maxPrice = parseFloat(document.getElementById('filter-price')?.value) || null;
      const esimOnly = document.getElementById('filter-esim')?.checked || false;

      let filtered = [...allDevices];

      // Text search filter
      if (searchQuery) {
        filtered = filtered.filter(device => {
          const name = (device.name || device.translated?.name || '').toLowerCase();
          const brand = (device.manufacturer?.name || device.brand || device.translated?.manufacturer?.name || '').toLowerCase();
          const full = `${name} ${brand}`;
          return full.includes(searchQuery);
        });
      }

      // Brand filter (use same extraction logic)
      if (brandFilter) {
        filtered = filtered.filter(device => {
          const deviceBrand = extractBrandFromDevice(device);
          return deviceBrand.toLowerCase() === brandFilter.toLowerCase();
        });
      }

      // Price filter
      if (maxPrice !== null && maxPrice > 0) {
        filtered = filtered.filter(device => {
          const price = getDevicePrice(device);
          return typeof price === 'number' && price <= maxPrice;
        });
      }

      // eSIM filter
      if (esimOnly) {
        filtered = filtered.filter(device => isEsimCapable(device));
      }

      return filtered;
    }

    // Helper function to extract brand from device (same logic as renderDevice)
    function extractBrandFromDevice(device) {
      // Get brand from API
      let brand = device.manufacturer?.name || device.brand || device.translated?.manufacturer?.name || device.customFields?.brand || '';

      // Get device name
      let name = device.name || device.translated?.name || '';

      // Extract brand from device name if it starts with brand name
      if (brand && name.toLowerCase().startsWith(brand.toLowerCase())) {
        // Brand already extracted
      } else if (!brand && name) {
        // If no brand from API, try to extract from name (first word)
        const nameParts = name.split(' ');
        if (nameParts.length > 1) {
          brand = nameParts[0];
        }
      }

      // Fallback if brand is still empty
      if (!brand) {
        brand = 'Unknown Brand';
      }

      return brand;
    }

    function updateFilterUI() {
      const devices = extractDevices();
      if (devices.length === 0) return;

      allDevices = devices;
      const filtersContainer = document.getElementById('filters-container');
      const brandSelect = document.getElementById('filter-brand');

      // Extract unique brands using the same logic as renderDevice
      const brandSet = new Set();
      devices.forEach(device => {
        const brandName = extractBrandFromDevice(device);
        if (brandName && brandName !== 'Unknown Brand') {
          brandSet.add(brandName);
        }
      });

      // Populate brand dropdown
      const brands = Array.from(brandSet).sort();
      brandSelect.innerHTML = '<option value="">All Brands</option>';
      brands.forEach(brand => {
        const option = document.createElement('option');
        option.value = brand;
        option.textContent = brand;
        brandSelect.appendChild(option);
      });

      console.log('Brands extracted for filter:', brands);

      // Show filters container
      if (filtersContainer) {
        filtersContainer.style.display = 'block';
      }

      // Set up filter event listeners
      document.getElementById('filter-search')?.addEventListener('input', applyFilters);
      document.getElementById('filter-brand')?.addEventListener('change', applyFilters);
      document.getElementById('filter-price')?.addEventListener('input', applyFilters);
      document.getElementById('filter-esim')?.addEventListener('change', applyFilters);
    }

    function toggleEsimFilter() {
      const checkbox = document.getElementById('filter-esim');
      if (checkbox) {
        checkbox.checked = !checkbox.checked;
        applyFilters();
      }
    }

    function applyFilters() {
      const container = document.getElementById('devices-container');
      const resultsCountDiv = document.getElementById('filter-results-count');

      if (!container) return;

      const filtered = filterDevices();

      // Update results count with elegant display
      if (resultsCountDiv) {
        const activeFilters = [];
        if (document.getElementById('filter-search')?.value.trim()) activeFilters.push('search');
        if (document.getElementById('filter-brand')?.value) activeFilters.push('brand');
        if (document.getElementById('filter-price')?.value) activeFilters.push('price');
        if (document.getElementById('filter-esim')?.checked) activeFilters.push('eSIM');

        if (activeFilters.length > 0) {
          resultsCountDiv.innerHTML = `Showing <strong>${filtered.length}</strong> of <strong>${allDevices.length}</strong> devices`;
        } else {
          resultsCountDiv.innerHTML = `Showing all <strong>${allDevices.length}</strong> devices`;
        }
      }

      // Render filtered devices
      if (filtered.length === 0) {
        container.innerHTML = `
          <div class="no-results">
            <div class="no-results-icon">üîç</div>
            <div class="no-results-title">No devices found</div>
            <div class="no-results-text">Try adjusting your filters to see more results.</div>
            <button class="clear-filters-btn" onclick="clearFilters()">
              <span>üîÑ</span>
              <span>Clear All Filters</span>
            </button>
          </div>
        `;
      } else {
        const devicesHtml = filtered.map(renderDevice).join('');
        container.innerHTML = devicesHtml;
      }
    }

    function clearFilters() {
      document.getElementById('filter-search').value = '';
      document.getElementById('filter-brand').value = '';
      document.getElementById('filter-price').value = '';
      document.getElementById('filter-esim').checked = false;
      applyFilters();
    }

    // Function to replace failed logo image with SVG (called by onerror handler)
    function replaceLogoWithSVG(imgElement) {
      if (!imgElement || imgElement.dataset.svgReplaced) return;
      imgElement.dataset.svgReplaced = 'true';

      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('width', '120');
      svg.setAttribute('height', '30');
      svg.setAttribute('viewBox', '0 0 120 30');
      svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
      svg.setAttribute('aria-label', imgElement.alt || 'Terrace Finance logo');
      svg.style.cssText = 'height: 18px; width: auto; display: inline-block; vertical-align: middle;';

      const text1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      text1.setAttribute('x', '0');
      text1.setAttribute('y', '12');
      text1.setAttribute('font-family', 'Arial, sans-serif');
      text1.setAttribute('font-size', '11');
      text1.setAttribute('font-weight', 'bold');
      text1.setAttribute('fill', '#1e3a8a');
      text1.textContent = 'TERRACE';
      svg.appendChild(text1);

      const text2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      text2.setAttribute('x', '0');
      text2.setAttribute('y', '25');
      text2.setAttribute('font-family', 'Arial, sans-serif');
      text2.setAttribute('font-size', '10');
      text2.setAttribute('font-weight', 'normal');
      text2.setAttribute('fill', '#000000');
      text2.textContent = 'FINANCE';
      svg.appendChild(text2);

      const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      g.setAttribute('transform', 'translate(65, 4)');

      const bars = [
        { x: 0, y: 0, w: 12 },
        { x: 2, y: 5, w: 18 },
        { x: 4, y: 10, w: 24 }
      ];

      bars.forEach(bar => {
        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('x', bar.x);
        rect.setAttribute('y', bar.y);
        rect.setAttribute('width', bar.w);
        rect.setAttribute('height', '2.5');
        rect.setAttribute('rx', '1.25');
        rect.setAttribute('fill', '#2563eb');
        g.appendChild(rect);
      });

      svg.appendChild(g);
      imgElement.parentElement.replaceChild(svg, imgElement);
    }

    /**
     * Handle device image loading errors with a multi-stage fallback:
     * 1. Try primary API URL (already failed if this is called)
     * 2. Try local fallback URL (cached image)
     * 3. Show generic placeholder if both fail
     */
    function handleDeviceImageError(imgElement, fallback) {
      if (!imgElement) return;

      // If we've already tried the fallback and it failed too
      if (imgElement.dataset.triedFallback === 'true') {
        renderDevicePlaceholder(imgElement);
        return;
      }

      // If we have a fallback URL (could be remote API or local depending on search order)
      if (fallback && fallback !== imgElement.src) {
        imgElement.dataset.triedFallback = 'true';
        imgElement.src = fallback;
        console.log('üîÑ Primary image failed, trying fallback:', fallback);
      } else {
        // No fallback available, show placeholder
        renderDevicePlaceholder(imgElement);
      }
    }

    /**
     * Enhanced error handler for multiple fallbacks (Base64 -> Local -> Remote)
     */
    function handleDeviceImageEnhancedError(imgElement) {
      if (!imgElement) return;

      try {
        const fallbacks = JSON.parse(imgElement.dataset.fallbacks || '[]');
        let index = parseInt(imgElement.dataset.fallbackIndex || '0');

        if (index < fallbacks.length) {
          const nextFallback = fallbacks[index];
          imgElement.dataset.fallbackIndex = (index + 1).toString();
          imgElement.src = nextFallback;
          console.log(`üîÑ Image failed, trying fallback ${index + 1}:`, nextFallback);
        } else {
          renderDevicePlaceholder(imgElement);
        }
      } catch (e) {
        console.error('Error in enhanced image fallback:', e);
        renderDevicePlaceholder(imgElement);
      }
    }

    /**
     * Replace an image with a generic device placeholder
     */
    function renderDevicePlaceholder(imgElement) {
      if (!imgElement || imgElement.dataset.placeholderSet) return;
      imgElement.dataset.placeholderSet = 'true';

      const placeholder = document.createElement('div');
      placeholder.className = 'device-image-placeholder';
      placeholder.innerHTML = 'üì±';

      if (imgElement.parentElement) {
        imgElement.parentElement.replaceChild(placeholder, imgElement);
      }
    }

    // Function to ensure logos are rendered (fallback for data URI issues)
    function ensureLogosRendered() {
      // Use setTimeout to allow images time to load/error
      setTimeout(() => {
        const logos = document.querySelectorAll('.financing-logo img:not([data-svg-replaced])');
        logos.forEach(img => {
          // Check if image failed to load
          if (!img.complete || img.naturalHeight === 0) {
            replaceLogoWithSVG(img);
          }
        });
      }, 100);
    }

    // Function to render all devices
    function renderAllDevices() {
      const container = document.getElementById('devices-container');
      if (!container) {
        console.error('Devices container not found');
        return false;
      }

      const devices = extractDevices();

      // Update current lines from toolOutput
      const extractedLines = extractLines();
      if (extractedLines.length > 0) {
        currentLines = extractedLines;
        console.log('‚úÖ Lines updated:', currentLines.length, 'lines');
      }

      if (devices.length === 0) {
        return false;
      } else {
        // Store devices and set up filters
        allDevices = devices;
        updateFilterUI();

        // Render all devices initially
        const devicesHtml = devices.map(renderDevice).join('');
        container.innerHTML = devicesHtml;

        // Ensure logos are rendered (fallback for environments that block data URIs)
        ensureLogosRendered();

        // Update results count
        const resultsCountDiv = document.getElementById('filter-results-count');
        if (resultsCountDiv) {
          resultsCountDiv.innerHTML = `Showing all <strong>${devices.length}</strong> devices`;
        }

        // Update confirm buttons after rendering
        setTimeout(() => {
          updateConfirmButtons();
        }, 10);

        return true;
      }
    }

    // Permanent solution: Watch for toolOutput changing from null to data
    let rendered = false;
    let lastToolOutputValue = null;
    let lastLinesCount = 0;
    let checkCount = 0;
    const startTime = Date.now();
    const maxChecks = 1000;
    const minChecksBeforeError = 800;
    const minTimeBeforeError = 20000;

    function watchForToolOutputChange() {
      checkCount++;
      const elapsedTime = Date.now() - startTime;

      // Check if lines data has changed
      const extractedLines = extractLines();
      const linesChanged = extractedLines.length !== lastLinesCount;
      if (linesChanged && extractedLines.length > 0) {
        lastLinesCount = extractedLines.length;
        currentLines = extractedLines;
        console.log('‚úÖ Lines data updated, re-rendering devices:', currentLines.length, 'lines');
        // Re-render even if already rendered to update line checkboxes
        const success = renderAllDevices();
        if (success && !rendered) {
          rendered = true;
        }
      }

      if (!rendered) {
        if (hasValidToolOutput()) {
          const success = renderAllDevices();
          if (success) {
            console.log('‚úÖ Devices rendered successfully (toolOutput populated)');
            rendered = true;
            return;
          }
        }

        const currentValue = window.openai?.toolOutput;
        if (currentValue !== lastToolOutputValue) {
          lastToolOutputValue = currentValue;

          if (currentValue !== null && currentValue !== undefined) {
            console.log('toolOutput changed from null to:', typeof currentValue);
            const success = renderAllDevices();
            if (success) {
              console.log('‚úÖ Devices rendered (value change detected)');
              rendered = true;
              return;
            }
          }
        }
      }

      if (checkCount < maxChecks) {
        setTimeout(watchForToolOutputChange, 25);
      } else if (!rendered && checkCount >= maxChecks) {
        if (checkCount >= minChecksBeforeError && elapsedTime >= minTimeBeforeError) {
          const container = document.getElementById('devices-container');
          if (container) {
            const debugInfo = window.openai ?
              `<p style="padding: 10px; background: #fff3cd; border: 1px solid #ffc107; border-radius: 4px; margin: 10px 0;">
            <strong>Debug Info:</strong><br>
            window.openai exists: ‚úÖ<br>
            toolOutput exists: ${window.openai.toolOutput ? '‚úÖ' : '‚ùå'}<br>
            toolResponseMetadata exists: ${window.openai.toolResponseMetadata ? '‚úÖ' : '‚ùå'}<br>
            Available keys: ${Object.keys(window.openai).join(', ')}<br>
            toolOutput value: ${JSON.stringify(window.openai.toolOutput || 'null', null, 2)}
          </p>` :
              '<p style="padding: 10px; background: #f8d7da; border: 1px solid #dc3545; border-radius: 4px; margin: 10px 0;"><strong>Error:</strong> window.openai is not available</p>';

            container.innerHTML = debugInfo + '<p style="padding: 20px; text-align: center; color: #d32f2f;">‚ö†Ô∏è Unable to load devices. Please try again.</p>';
          }
        } else {
          setTimeout(watchForToolOutputChange, 25);
        }
      }
    }

    // Try to intercept toolOutput property changes using Proxy/defineProperty
    function setupToolOutputWatcher() {
      if (!window.openai) {
        setTimeout(setupToolOutputWatcher, 100);
        return;
      }

      try {
        let currentValue = window.openai.toolOutput;

        Object.defineProperty(window.openai, 'toolOutput', {
          get: function () {
            return currentValue;
          },
          set: function (newValue) {
            currentValue = newValue;

            if (newValue !== null && newValue !== undefined &&
              typeof newValue === 'object') {

              console.log('‚úÖ toolOutput changed from null to data!', newValue);

              setTimeout(() => {
                if (!rendered) {
                  const success = renderAllDevices();
                  if (success) {
                    rendered = true;
                    console.log('‚úÖ Devices rendered (property setter detected)');
                  }
                }
              }, 10);
            }
          },
          configurable: true,
          enumerable: true
        });

        console.log('‚úÖ Set up toolOutput property watcher');
      } catch (e) {
        console.warn('Could not set up property watcher (this is OK, using polling instead):', e.message);
      }
    }

    // Start the permanent solution immediately
    setupToolOutputWatcher();
    watchForToolOutputChange();

    // Also listen for load event as fallback
    window.addEventListener("load", () => {
      console.log('üì• Load event fired, attempting to render devices');
      if (!rendered) {
        const success = renderAllDevices();
        if (success) {
          rendered = true;
          console.log('‚úÖ Devices rendered on load event');
        }
      }
    });

    // Also try on DOMContentLoaded
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        console.log('üì• DOMContentLoaded fired, attempting to render devices');
        if (!rendered) {
          const success = renderAllDevices();
          if (success) {
            rendered = true;
            console.log('‚úÖ Devices rendered on DOMContentLoaded');
          }
        }
      });
    } else {
      console.log('üì• DOM already loaded, attempting immediate render');
      if (!rendered) {
        const success = renderAllDevices();
        if (success) {
          rendered = true;
          console.log('‚úÖ Devices rendered (DOM already loaded)');
        }
      }
    }
  </script>
</body>

</html>